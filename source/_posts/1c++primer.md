### 无符号和有符号赋值超过范围

![image-20220526210355126](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526210355126.png)



### 局部变量定义后未初始化

![image-20220526211329337](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526211329337.png)

字符串数组始终会被初始化。  （即使在局部变量）



### 初始化的类型

![image-20220526214601383](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526214601383.png)



### 使用getline和>>赋值到string

\>> 忽略所有空白符

getline  保留制表符、空格、不保留回车

即

- 类似`is >> s`的读取：string对象会忽略开头的空白并从第一个真正的字符开始，直到遇见下一**空白**为止。
- 类似`getline(is, s)`的读取：string对象会从输入流中读取字符，直到遇见**换行符**为止。

### c++头文件和c头文件的区别

- ctype.h vs. cctype

  ：C++修改了c的标准库，名称为去掉

  ```
  .h
  ```

  ，前面加

  ```
  c
  ```

  。

  > 如c++版本为`cctype`，c版本为`ctype.h`

  - **尽量使用c++版本的头文件**，即`cctype`



### 函数运算顺序

- 求值顺序

  ：

  ```
  int i = f1() + f2()
  ```

  - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义



### 前置++和后置++ 

## 递增递减运算符

- 前置版本`j = ++i`，先加一后赋值
- 后置版本`j = i++`，先赋值后加一

**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）



### ++运算符高于*解引用

### 混用解引用和递增运算符

`*iter++`等价于`*(iter++)`，递增优先级较高

```
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性



### c++与java区别

C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。



### 什么是溢出

当计算的结果超出该类型所能表示的范围时就会产生溢出。最终结果为真实结果对类型表示总的个数取模。

例 char a = 255 ；a+1=0      256%256=0；

```
short svalue = 32767; ++svalue; // -32768
unsigned uivalue = 0; --uivalue;  // 4294967295
unsigned short usvalue = 65535; ++usvalue;  // 0
```



### 内联函数 inline

### 内联（inline）函数

- 普通函数的缺点：调用函数比求解等价表达式要慢得多。
- `inline`函数可以避免函数调用的开销，可以让编译器在编译时**内联地展开**该函数。
- `inline`函数应该在头文件中定义。
- 一般来说，内联机制用于优化规模小、流程直接、频繁调用的函数。



### constexpr函数

- 指能用于常量表达式的函数。
- `constexpr int new_sz() {return 42;}`
- 函数的返回类型及所有形参类型都要是字面值类型。
- `constexpr`函数应该在头文件中定义。



### 可变形参initializer_list

### 可变形参

`initializer_list`提供的操作（`C++11`）：

| 操作                                 | 解释                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| `initializer_list<T> lst;`           | 默认初始化；`T`类型元素的空列表                              |
| `initializer_list<T> lst{a,b,c...};` | `lst`的元素数量和初始值一样多；`lst`的元素是对应初始值的副本；列表中的元素是`const`。 |
| `lst2(lst)`                          | 拷贝或赋值一个`initializer_list`对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 |
| `lst2 = lst`                         | 同上                                                         |
| `lst.size()`                         | 列表中的元素数量                                             |
| `lst.begin()`                        | 返回指向`lst`中首元素的指针                                  |
| `lst.end()`                          | 返回指向`lst`中微元素下一位置的指针                          |

`initializer_list`使用demo：

```
void err_msg(ErrCode e, initializer_list<string> il){
    cout << e.msg << endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout << *beg << " ";
    cout << endl;
}

err_msg(ErrCode(0), {"functionX", "okay});
```



- 所有实参类型相同，可以使用 `initializer_list`的标准库类型。
- 实参类型不同，可以使用`可变参数模板`。
- 省略形参符： `...`，便于`C++`访问某些C代码，这些C代码使用了 `varargs`的C标准功能。



### vscode 中文不支持的解决办法

https://blog.csdn.net/qq_38026359/article/details/107188429



### vscode设置键盘快捷键

{
 "key": "alt+k",
 "command": "selectPrevSuggestion",
 "when": "editorTextFocus && suggestWidgetVisible"
    },
    {
 "key": "alt+j",
 "command": "selectNextSuggestion",
 "when": "editorTextFocus && suggestWidgetVisible"



### struct和class都可以定义类 及区别

类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。



### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。

#### 许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。（cl.exe不需要额外声明）



### 友元类

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员



### 类的作用域

在类外部定义的函数名需要加类名前缀   int class::get(){}

一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了



当函数返回类型为类内部定义的类型时，需要加类名前缀   class::myint class::get(){}

函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员



### 构造函数初始值 ：xxx{}

构造函数的初始值有时必不可少有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。

如果**成员是const或者是引用的话，必须将其初始化。**类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

例如：![image-20220531113511930](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113511930.png)和其他常量对象或者引用一样，成员ci和ri都必须被初始化。因此，如果我们没有为它们提供构造函数初始值的话将引发错误：![image-20220531113527263](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113527263.png)随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：[![image-20220531113539925](C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113539925.png)][插图]如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。

建议：使用构造函数初始值在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。

除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。



### 成员初始化顺序

构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。



# c++ 基础

## 修饰访问符

> public 成员可以通过对象来访问，private 成员不能通过对象访问。
>
> protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用

## 继承方式的修饰访问符

> 不同的继承方式会影响基类成员在派生类中的访问权限。
>
> **1) public继承方式**
>
> - 基类中所有 public 成员在派生类中为 public 属性；
> - 基类中所有 protected 成员在派生类中为 protected 属性；
> - 基类中所有 private 成员在派生类中不能使用。
>
> 
> **2) protected继承方式**
>
> - 基类中的所有 public 成员在派生类中为 protected 属性；
> - 基类中的所有 protected 成员在派生类中为 protected 属性；
> - 基类中的所有 private 成员在派生类中不能使用。
>
> 
> **3) private继承方式**
>
> - 基类中的所有 public 成员在派生类中均为 private 属性；
> - 基类中的所有 protected 成员在派生类中均为 private 属性；
> - 基类中的所有 private 成员在派生类中不能使用。

## 多态

基类指针只可以访问派生类的成员变量，不能访问函数

在基类的同名函数前加入关键字virtual，后此时基类指针可以访问函数

> C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。

# VS STUDIO 遇到的报错

## 重定义默认参数

c++ 默认参数 

1. 只能在声明或定义中出现，不能都出现
2. 默认参数后的参数都必须为默认参数，后指从左往右

