<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">

<link rel="stylesheet" href="/blog/css/main.css">


<link rel="stylesheet" href="/blog/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"pleasecallmeboss.github.io","root":"/blog/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="咦蜘蛛的个人博客">
<meta property="og:url" content="https://pleasecallmeboss.github.io/blog/page/2/index.html">
<meta property="og:site_name" content="咦蜘蛛的个人博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="咦蜘蛛">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://pleasecallmeboss.github.io/blog/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>咦蜘蛛的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">咦蜘蛛的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/09/26/1git%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/09/26/1git%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 17:15:39" itemprop="dateCreated datePublished" datetime="2022-09-26T17:15:39+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-08 10:51:52" itemprop="dateModified" datetime="2022-10-08T10:51:52+08:00">2022-10-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="https和git区别"><a href="#https和git区别" class="headerlink" title="https和git区别"></a>https和git区别</h3><p>https clone不需要密码，push需要用户名和密码</p>
<p>git需要配置密钥</p>
<h3 id="在本地仓库添加远程映射"><a href="#在本地仓库添加远程映射" class="headerlink" title="在本地仓库添加远程映射"></a>在本地仓库添加远程映射</h3><p>git remote add 远程仓库别名 远程仓库地址</p>
<h3 id="从其他地方复制的公私钥不起作用"><a href="#从其他地方复制的公私钥不起作用" class="headerlink" title="从其他地方复制的公私钥不起作用"></a>从其他地方复制的公私钥不起作用</h3><p>更改权限为其他人无法操作 700</p>
<p>ssh-add 私钥文件</p>
<h1 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h1><p>初始化<br>git init<br>git config –global user.name=’’<br>git config –global user.email=’’</p>
<p>创建、合并分支<br>git checkout -b 分支名</p>
<h1 id="配置git自动补全"><a href="#配置git自动补全" class="headerlink" title="配置git自动补全"></a>配置git自动补全</h1><p>直接下载 Git 的源代码，进入 contrib/completion 目录，会看到一个 git-completion.bash 文件。<br>git clone <a target="_blank" rel="noopener" href="https://github.com/git/git.git">https://github.com/git/git.git</a><br>(不推荐直接下载git源码，容量过大；建议直接去github中搜git官方托管库，按以上方法查找到git-completion.bash 文件进行下载，注意下载后文件所放地)<br>将下载好的该文件复制到你自己的用户主目录中（此处主目录是指你git下的目录，在windows下一般放于git\Git\etc文件下，以下以个人电脑为例，重点重点是找到自己存放git目录）<br><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/git_location.png"><br>3.将git-completion.bash文件改成.git-completion.bash。<br>4.在etc文件夹下找到bash.bashrc文件，打开该文件，在其末尾添加<br>source .git-completion.bash<br>键入 git co 然后连按两次 Tab 键，会看到两个相关的建议（命令） commit 和 config。继而输入 m<tab> 会自动完成 git commit 命令的输入。到此处说明你已成功设置好了。</p>
<p>需要在git自带的bash中才可以运行，想在powershell使用将git下的bash.exe添加到环境变量中，然后注销生效，输入bash进入bash环境</p>
<h1 id="解决git命令行下中文无法显示的问题"><a href="#解决git命令行下中文无法显示的问题" class="headerlink" title="解决git命令行下中文无法显示的问题"></a>解决git命令行下中文无法显示的问题</h1><p>解决办法<br>          通过修改配置让git 能显示中文，利用中文文件名来 add 到 git</p>
<p>git bash 终端输入命令：git config –global core.quotepath false<br>在git bash的界面中右击空白处，弹出菜单，选择Options-&gt;Text-&gt;Locale改为zh_CN，Character set改为UTF-8<br>          动图演示</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h3 id="gitignore的使用"><a href="#gitignore的使用" class="headerlink" title=".gitignore的使用"></a>.gitignore的使用</h3><h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><pre><code>      在看看是不是变成中文了，的确变了
</code></pre>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>3d419ebd75fa478d0e144fedfe1049e3bc140131</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/09/26/1clion/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/09/26/1clion/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 17:15:39" itemprop="dateCreated datePublished" datetime="2022-09-26T17:15:39+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-28 17:38:57" itemprop="dateModified" datetime="2023-02-28T17:38:57+08:00">2023-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="devel目录"><a href="#devel目录" class="headerlink" title="devel目录"></a>devel目录</h3><p>-DCATKIN_DEVEL_PREFIX:PATH=/home/ljy/projects/fast-planner/devel</p>
<h3 id="build目录"><a href="#build目录" class="headerlink" title="build目录"></a>build目录</h3><p>/home/ljy/projects/fast-planner/build</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/09/26/1c++primer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/09/26/1c++primer/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 17:15:39" itemprop="dateCreated datePublished" datetime="2022-09-26T17:15:39+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-28 17:38:47" itemprop="dateModified" datetime="2023-02-28T17:38:47+08:00">2023-02-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="无符号和有符号赋值超过范围"><a href="#无符号和有符号赋值超过范围" class="headerlink" title="无符号和有符号赋值超过范围"></a>无符号和有符号赋值超过范围</h3><p><img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526210355126.png" alt="image-20220526210355126"></p>
<h3 id="局部变量定义后未初始化"><a href="#局部变量定义后未初始化" class="headerlink" title="局部变量定义后未初始化"></a>局部变量定义后未初始化</h3><p><img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526211329337.png" alt="image-20220526211329337"></p>
<p>字符串数组始终会被初始化。  （即使在局部变量）</p>
<h3 id="初始化的类型"><a href="#初始化的类型" class="headerlink" title="初始化的类型"></a>初始化的类型</h3><p><img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220526214601383.png" alt="image-20220526214601383"></p>
<h3 id="使用getline和-gt-gt-赋值到string"><a href="#使用getline和-gt-gt-赋值到string" class="headerlink" title="使用getline和&gt;&gt;赋值到string"></a>使用getline和&gt;&gt;赋值到string</h3><p>&gt;&gt; 忽略所有空白符</p>
<p>getline  保留制表符、空格、不保留回车</p>
<p>即</p>
<ul>
<li>类似<code>is &gt;&gt; s</code>的读取：string对象会忽略开头的空白并从第一个真正的字符开始，直到遇见下一<strong>空白</strong>为止。</li>
<li>类似<code>getline(is, s)</code>的读取：string对象会从输入流中读取字符，直到遇见<strong>换行符</strong>为止。</li>
</ul>
<h3 id="c-头文件和c头文件的区别"><a href="#c-头文件和c头文件的区别" class="headerlink" title="c++头文件和c头文件的区别"></a>c++头文件和c头文件的区别</h3><ul>
<li><p>ctype.h vs. cctype</p>
<p>：C++修改了c的标准库，名称为去掉</p>
<pre><code>.h
</code></pre>
<p>，前面加</p>
<pre><code>c
</code></pre>
<p>。</p>
<blockquote>
<p>如c++版本为<code>cctype</code>，c版本为<code>ctype.h</code></p>
</blockquote>
<ul>
<li><strong>尽量使用c++版本的头文件</strong>，即<code>cctype</code></li>
</ul>
</li>
</ul>
<h3 id="函数运算顺序"><a href="#函数运算顺序" class="headerlink" title="函数运算顺序"></a>函数运算顺序</h3><ul>
<li><p>求值顺序</p>
<p>：</p>
<pre><code>int i = f1() + f2()
</code></pre>
<ul>
<li>先计算<code>f1() + f2()</code>,再计算<code>int i = f1() + f2()</code>。但是f1和f2的计算<strong>先后不确定</strong></li>
<li>但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义</li>
</ul>
</li>
</ul>
<h3 id="前置-和后置"><a href="#前置-和后置" class="headerlink" title="前置++和后置++"></a>前置++和后置++</h3><h2 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h2><ul>
<li>前置版本<code>j = ++i</code>，先加一后赋值</li>
<li>后置版本<code>j = i++</code>，先赋值后加一</li>
</ul>
<p><strong>优先使用前置</strong>版本，后置多一步储存原始值。（除非需要变化前的值）</p>
<h3 id="运算符高于-解引用"><a href="#运算符高于-解引用" class="headerlink" title="++运算符高于*解引用"></a>++运算符高于*解引用</h3><h3 id="混用解引用和递增运算符"><a href="#混用解引用和递增运算符" class="headerlink" title="混用解引用和递增运算符"></a>混用解引用和递增运算符</h3><p><code>*iter++</code>等价于<code>*(iter++)</code>，递增优先级较高</p>
<pre><code>auto iter = vi.begin();
while (iter!=vi.end()&amp;&amp;*iter&gt;=0)
 cout&lt;&lt;*iter++&lt;&lt;endl; // 输出当前值，指针向前移1
</code></pre>
<blockquote>
<p><strong>简介是一种美德</strong>，追求简洁能降低程序出错可能性</p>
</blockquote>
<h3 id="c-与java区别"><a href="#c-与java区别" class="headerlink" title="c++与java区别"></a>c++与java区别</h3><p>C++的设计思想是尽可能地“相信”程序员，将效率最大化。然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。</p>
<h3 id="什么是溢出"><a href="#什么是溢出" class="headerlink" title="什么是溢出"></a>什么是溢出</h3><p>当计算的结果超出该类型所能表示的范围时就会产生溢出。最终结果为真实结果对类型表示总的个数取模。</p>
<p>例 char a = 255 ；a+1=0      256%256=0；</p>
<pre><code>short svalue = 32767; ++svalue; // -32768
unsigned uivalue = 0; --uivalue;  // 4294967295
unsigned short usvalue = 65535; ++usvalue;  // 0
</code></pre>
<h3 id="内联函数-inline"><a href="#内联函数-inline" class="headerlink" title="内联函数 inline"></a>内联函数 inline</h3><h3 id="内联（inline）函数"><a href="#内联（inline）函数" class="headerlink" title="内联（inline）函数"></a>内联（inline）函数</h3><ul>
<li>普通函数的缺点：调用函数比求解等价表达式要慢得多。</li>
<li><code>inline</code>函数可以避免函数调用的开销，可以让编译器在编译时<strong>内联地展开</strong>该函数。</li>
<li><code>inline</code>函数应该在头文件中定义。</li>
<li>一般来说，内联机制用于优化规模小、流程直接、频繁调用的函数。</li>
</ul>
<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><ul>
<li>指能用于常量表达式的函数。</li>
<li><code>constexpr int new_sz() &#123;return 42;&#125;</code></li>
<li>函数的返回类型及所有形参类型都要是字面值类型。</li>
<li><code>constexpr</code>函数应该在头文件中定义。</li>
</ul>
<h3 id="可变形参initializer-list"><a href="#可变形参initializer-list" class="headerlink" title="可变形参initializer_list"></a>可变形参initializer_list</h3><h3 id="可变形参"><a href="#可变形参" class="headerlink" title="可变形参"></a>可变形参</h3><p><code>initializer_list</code>提供的操作（<code>C++11</code>）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>initializer_list&lt;T&gt; lst;</code></td>
<td>默认初始化；<code>T</code>类型元素的空列表</td>
</tr>
<tr>
<td><code>initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;</code></td>
<td><code>lst</code>的元素数量和初始值一样多；<code>lst</code>的元素是对应初始值的副本；列表中的元素是<code>const</code>。</td>
</tr>
<tr>
<td><code>lst2(lst)</code></td>
<td>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</td>
</tr>
<tr>
<td><code>lst2 = lst</code></td>
<td>同上</td>
</tr>
<tr>
<td><code>lst.size()</code></td>
<td>列表中的元素数量</td>
</tr>
<tr>
<td><code>lst.begin()</code></td>
<td>返回指向<code>lst</code>中首元素的指针</td>
</tr>
<tr>
<td><code>lst.end()</code></td>
<td>返回指向<code>lst</code>中微元素下一位置的指针</td>
</tr>
</tbody></table>
<p><code>initializer_list</code>使用demo：</p>
<pre><code>void err_msg(ErrCode e, initializer_list&lt;string&gt; il)&#123;
    cout &lt;&lt; e.msg &lt;&lt; endl;
    for (auto bed = il.begin(); beg != il.end(); ++ beg)
        cout &lt;&lt; *beg &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl;
&#125;

err_msg(ErrCode(0), &#123;&quot;functionX&quot;, &quot;okay&#125;);
</code></pre>
<ul>
<li>所有实参类型相同，可以使用 <code>initializer_list</code>的标准库类型。</li>
<li>实参类型不同，可以使用<code>可变参数模板</code>。</li>
<li>省略形参符： <code>...</code>，便于<code>C++</code>访问某些C代码，这些C代码使用了 <code>varargs</code>的C标准功能。</li>
</ul>
<h3 id="vscode-中文不支持的解决办法"><a href="#vscode-中文不支持的解决办法" class="headerlink" title="vscode 中文不支持的解决办法"></a>vscode 中文不支持的解决办法</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38026359/article/details/107188429">https://blog.csdn.net/qq_38026359/article/details/107188429</a></p>
<h3 id="vscode设置键盘快捷键"><a href="#vscode设置键盘快捷键" class="headerlink" title="vscode设置键盘快捷键"></a>vscode设置键盘快捷键</h3><p>{<br> “key”: “alt+k”,<br> “command”: “selectPrevSuggestion”,<br> “when”: “editorTextFocus &amp;&amp; suggestWidgetVisible”<br>    },<br>    {<br> “key”: “alt+j”,<br> “command”: “selectNextSuggestion”,<br> “when”: “editorTextFocus &amp;&amp; suggestWidgetVisible”</p>
<h3 id="struct和class都可以定义类-及区别"><a href="#struct和class都可以定义类-及区别" class="headerlink" title="struct和class都可以定义类 及区别"></a>struct和class都可以定义类 及区别</h3><p>类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反，如果我们使用class关键字，则这些成员是private的。</p>
<h3 id="友元的声明"><a href="#友元的声明" class="headerlink" title="友元的声明"></a>友元的声明</h3><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。</p>
<p>为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。因此，我们的Sales_data头文件应该为read、print和add提供独立的声明（除了类内部的友元声明之外）。</p>
<h4 id="许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。（cl-exe不需要额外声明）"><a href="#许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。（cl-exe不需要额外声明）" class="headerlink" title="许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。（cl.exe不需要额外声明）"></a>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。（cl.exe不需要额外声明）</h4><h3 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h3><p>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员</p>
<h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><p>在类外部定义的函数名需要加类名前缀   int class::get(){}</p>
<p>一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了</p>
<p>当函数返回类型为类内部定义的类型时，需要加类名前缀   class::myint class::get(){}</p>
<p>函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员</p>
<h3 id="构造函数初始值-：xxx"><a href="#构造函数初始值-：xxx" class="headerlink" title="构造函数初始值 ：xxx{}"></a>构造函数初始值 ：xxx{}</h3><p>构造函数的初始值有时必不可少有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。</p>
<p>如果<strong>成员是const或者是引用的话，必须将其初始化。</strong>类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。</p>
<p>例如：<img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113511930.png" alt="image-20220531113511930">和其他常量对象或者引用一样，成员ci和ri都必须被初始化。因此，如果我们没有为它们提供构造函数初始值的话将引发错误：<img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113527263.png" alt="image-20220531113527263">随着构造函数体一开始执行，初始化就完成了。我们初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式应该是：[<img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220531113539925.png" alt="image-20220531113539925">][插图]如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p>
<p>建议：使用构造函数初始值在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。</p>
<p>除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。</p>
<h3 id="成员初始化顺序"><a href="#成员初始化顺序" class="headerlink" title="成员初始化顺序"></a>成员初始化顺序</h3><p>构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</p>
<h1 id="c-基础"><a href="#c-基础" class="headerlink" title="c++ 基础"></a>c++ 基础</h1><h2 id="修饰访问符"><a href="#修饰访问符" class="headerlink" title="修饰访问符"></a>修饰访问符</h2><blockquote>
<p>public 成员可以通过对象来访问，private 成员不能通过对象访问。</p>
<p>protected 成员和 private 成员类似，也不能通过对象访问。但是当存在继承关系时，protected 和 private 就不一样了：基类中的 protected 成员可以在派生类中使用，而基类中的 private 成员不能在派生类中使用</p>
</blockquote>
<h2 id="继承方式的修饰访问符"><a href="#继承方式的修饰访问符" class="headerlink" title="继承方式的修饰访问符"></a>继承方式的修饰访问符</h2><blockquote>
<p>不同的继承方式会影响基类成员在派生类中的访问权限。</p>
<p><strong>1) public继承方式</strong></p>
<ul>
<li>基类中所有 public 成员在派生类中为 public 属性；</li>
<li>基类中所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中所有 private 成员在派生类中不能使用。</li>
</ul>
<p><strong>2) protected继承方式</strong></p>
<ul>
<li>基类中的所有 public 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 protected 成员在派生类中为 protected 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
<p><strong>3) private继承方式</strong></p>
<ul>
<li>基类中的所有 public 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 protected 成员在派生类中均为 private 属性；</li>
<li>基类中的所有 private 成员在派生类中不能使用。</li>
</ul>
</blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>基类指针只可以访问派生类的成员变量，不能访问函数</p>
<p>在基类的同名函数前加入关键字virtual，后此时基类指针可以访问函数</p>
<blockquote>
<p>C++提供多态的目的是：可以通过基类指针对所有派生类（包括直接派生和间接派生）的成员变量和成员函数进行“全方位”的访问，尤其是成员函数。如果没有多态，我们只能访问成员变量。</p>
</blockquote>
<h1 id="VS-STUDIO-遇到的报错"><a href="#VS-STUDIO-遇到的报错" class="headerlink" title="VS STUDIO 遇到的报错"></a>VS STUDIO 遇到的报错</h1><h2 id="重定义默认参数"><a href="#重定义默认参数" class="headerlink" title="重定义默认参数"></a>重定义默认参数</h2><p>c++ 默认参数</p>
<ol>
<li>只能在声明或定义中出现，不能都出现</li>
<li>默认参数后的参数都必须为默认参数，后指从左往右</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/09/26/%E6%88%91%E7%9A%84%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/09/26/%E6%88%91%E7%9A%84%E7%BB%83%E4%B9%A0/" class="post-title-link" itemprop="url">未命名</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-26 17:15:39" itemprop="dateCreated datePublished" datetime="2022-09-26T17:15:39+08:00">2022-09-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-05-27 17:52:40" itemprop="dateModified" datetime="2022-05-27T17:52:40+08:00">2022-05-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="clion-的cmake问题"><a href="#clion-的cmake问题" class="headerlink" title="clion 的cmake问题"></a>clion 的cmake问题</h3><p>在设置中更改toolchains为系统cmake，clion自带cmake存在问题</p>
<h3 id="clion自定义devle和build路径"><a href="#clion自定义devle和build路径" class="headerlink" title="clion自定义devle和build路径"></a>clion自定义devle和build路径</h3><h3 id="cmakelists-txt文件详解"><a href="#cmakelists-txt文件详解" class="headerlink" title="cmakelists.txt文件详解"></a>cmakelists.txt文件详解</h3><p>ros wiki <a target="_blank" rel="noopener" href="http://wiki.ros.org/catkin/CMakeLists.txt">http://wiki.ros.org/catkin/CMakeLists.txt</a></p>
<p>generate_messages，指定生成消息文件时的依赖项，比如上面嵌套了其他消息类型geometry_msgs，那么必须注明</p>
<pre><code>generate_messages必须在catkin_package前面
generate_messages(
 DEPENDENCIES
 geometry_msgs
)
</code></pre>
<p><code>catkin_package</code>设置运行依赖</p>
<pre><code>catkin_package(

CATKIN_DEPENDS message_runtime

)
</code></pre>
<h3 id="cmakelists-txt文件中add-dependencies"><a href="#cmakelists-txt文件中add-dependencies" class="headerlink" title="cmakelists.txt文件中add_dependencies"></a>cmakelists.txt文件中add_dependencies</h3><p>add_dependencies(可执行或库名字 ${${PROJECT_NAME}_EXPORTED_TARGETS}) </p>
<p>用于自定义消息的头文件的生成</p>
<h3 id="桌面图标启动clion报错没有source-setup-bash"><a href="#桌面图标启动clion报错没有source-setup-bash" class="headerlink" title="桌面图标启动clion报错没有source setup.bash"></a>桌面图标启动clion报错没有source setup.bash</h3><p>从终端中启动clion</p>
<h3 id="自定义消息的头文件位置"><a href="#自定义消息的头文件位置" class="headerlink" title="自定义消息的头文件位置"></a>自定义消息的头文件位置</h3><p>编译后的中间文件查看:</p>
<p>C++ 需要调用的中间文件(…/工作空间/devel/include/包名/xxx.h)</p>
<p>Python 需要调用的中间文件(…/工作空间/devel/lib/python3/dist-packages/包名/msg)</p>
<h3 id="新建的py文件需要更改权限"><a href="#新建的py文件需要更改权限" class="headerlink" title="新建的py文件需要更改权限"></a>新建的py文件需要更改权限</h3><h3 id="自定义消息注意"><a href="#自定义消息注意" class="headerlink" title="自定义消息注意"></a>自定义消息注意</h3><p><img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220524102926156.png" alt="image-20220524102926156"></p>
<p>py文件：</p>
<p>c++文件：</p>
<p><img src="C:\Users\Delicious\AppData\Roaming\Typora\typora-user-images\image-20220524102910321.png" alt="image-20220524102910321"></p>
<h3 id="rqt-reconfigure的使用"><a href="#rqt-reconfigure的使用" class="headerlink" title="rqt_reconfigure的使用"></a>rqt_reconfigure的使用</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014610460/article/details/79531616">https://blog.csdn.net/u014610460/article/details/79531616</a>    cmakelists文件的写法</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45590473/article/details/122673314?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-122673314-blog-81811728.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/weixin_45590473/article/details/122673314?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0-122673314-blog-81811728.pc_relevant_paycolumn_v3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a>    cfg文件、客户端、服务端的写法</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/04/18/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%97%A5%E5%BF%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/04/18/%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%97%A5%E5%BF%97/" class="post-title-link" itemprop="url">实验室日志</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-18 14:00:18" itemprop="dateCreated datePublished" datetime="2022-04-18T14:00:18+08:00">2022-04-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-22 12:41:37" itemprop="dateModified" datetime="2022-10-22T12:41:37+08:00">2022-10-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/" itemprop="url" rel="index"><span itemprop="name">研究生</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>因为经常忘记自己任务进展状况，为了回忆进度和以备将来查询，特此记录。</p>
<h2 id="2022-4-18-周一"><a href="#2022-4-18-周一" class="headerlink" title="2022.4.18 周一"></a>2022.4.18 周一</h2><p>想法：确认两个摄像头的正常使用；检查在fp上是否存在崩溃的现象；和学长做实验。</p>
<p>现状：</p>
<p>jetpack 4.6.1 （l4t linux for tegra R32.7.1)</p>
<p>使用tx2中间realsense显示3.2接口，两个都能找到，</p>
<p>使用tx2边缘接口显示2.1接口，两个都能找到,</p>
<p>注意线</p>
<p>安装环境 px4和mavros</p>
<p>px4:</p>
<p>PX4是著名的开源无人机开发平台，它提供了一个<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83&spm=1001.2101.3001.7020">虚拟环境</a>，可以用来验证无人机的飞控算法，也可以连接开源硬件，为无人机的开发提供了极大便利。</p>
<p>对下载下来的PX4源码进行编译，命令为 make px4_sitl jmavsim（make px4_sitl gazebo_iris） ，编译成功后系统将自动打开 jMAVSim（gazebo），这时无人机仿真环境就出现了。</p>
<p><img src="https://img-blog.csdnimg.cn/073795d2bfa6434f97297f4f9ec37b91.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhhbmd6cTAy,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<ol start="10">
<li><p>当然还需要地面站模拟器（QGroundControl）。从官网上下载可执行文件 QGroundControl.AppImage，放到ubuntu目录下，双击运行。</p>
</li>
<li><p>这时就可以用 QGroundControl 模拟器来控制虚拟无人机了，如起飞、设置高度、航点等。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/900154a8096240d68d0ea6921e21226b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAemhhbmd6cTAy,size_16,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>仿真器可以让PX4飞行控制程序在仿真的“世界”中控制一架计算机模拟的飞行器。您可以使用QGroundControl地面站程序、API或遥控器与该飞行器进行交互，就像与真实飞行器进行交互一样。</p>
<pre><code>软件仿真是指PX4飞行控制程序运行在宿主机中，我们这里使用的宿主机是一台安装了ubuntu server的thinkpad笔记本计算机，PX4飞行控制程序安装在宿主机中。

 硬件仿真是指PX4飞行控制程序运行在真实飞控计算机中，我们这里使用的是一个安装了PX4飞行控制程序的pixhawk飞控计算机中。
</code></pre>
<p>仿真首先分为软件在环仿真（SITL）和硬件在环仿真（HITL）</p>
<p>软件在环仿真一共是有jMAVSim、Gazebo、AirSim这三种。jMAVSim是一个轻量级的仿真器，目前只支持四旋翼仿真。AirSim我不太清楚，没有使用过，这里就不评价了。Gazebo是我们今天的主角，支持旋翼、固定翼、倾转、小车等，是所有仿真器里支持平台最多的，也能支持多个无人机的仿真，在各个仿真器比较的表格里，PX4官方是这么说Gazebo仿真的：<strong>This simulator is highly recommended.</strong></p>
<h2 id="PX4的仿真是如何进行的？"><a href="#PX4的仿真是如何进行的？" class="headerlink" title="PX4的仿真是如何进行的？"></a>PX4的仿真是如何进行的？</h2><p>Flight stack代表飞控即PX4，Simulator代表仿真器（如Gazebo）。所有仿真器与PX4的通讯都是通过MAVLink消息来进行的，SITL使用simulator模块中的simulator_mavlink.cpp来处理这些消息，而HITL是使用mavlink模块中的mavlink_receiver.cpp来处理这些消息。梳理一下这里的消息流向：</p>
<p><strong>PX4到仿真器</strong>。PX4给仿真器只会发送一个HIL_ACTUATOR_CONTROLS的MAVLink消息，熟悉PX4的应该知道这个对应的uORB消息是actuator_outputs.msg，也就是姿态控制器最后的输出控制量。这里也就意味着，混控是在仿真器中进行的，仿真器中也包含电机的模型。</p>
<p><strong>仿真器到PX4</strong>。仿真器的作用就是模拟真实飞行，即模拟计算出真实飞行时的传感器状态，包括GPS，IMU等，将这些信息发送给飞控后，再由飞控中的估计模块计算出飞机状态量。</p>
<p><strong>外部到PX4</strong>。这里的外部就比如地面站QGC（可以外接遥控器），Mavros，Dronecode SDK等，这里也就可以模拟我们平时控制飞机的方式。</p>
<p><strong>端口号：</strong><br>PX4是使用UDP来进行这些消息通讯的。单个飞机仿真时，默认的UDP设置如下：</p>
<ul>
<li>UDP端口 <strong>14540</strong> 用于offboard模式的通讯。is used for communication with offboard APIs. Offboard APIs are expected to listen for connections on this port.</li>
<li>UDP端口 <strong>14550</strong> 用地面站的通讯。</li>
<li>TCP端口 <strong>4560</strong> 用于与仿真器的通讯。 PX4 listens to this port, and simulators are expected to initiate the communication by broadcasting data to this port.</li>
</ul>
<p>如果不涉及多个飞机的仿真，端口号默认都是设置好的，不需要修改及配置。如果是多个飞机的仿真，则需要配置每个飞机的端口号，不能重复，后续会详细介绍配置。</p>
<p>上述介绍适用所有的仿真器。</p>
<h2 id="ROS下的Gazebo仿真"><a href="#ROS下的Gazebo仿真" class="headerlink" title="ROS下的Gazebo仿真"></a>ROS下的Gazebo仿真</h2><p>除了上述的教程，在PX4开发手册中，还有一个属于Gazebo仿真的教程：ROS with Gazebo Simulation。这就是指导大家如何在ROS环境下，联合Mavros功能包进行仿真调试。我的固件按照这个教程一步一步走下来，没有任何问题。（PX4项目太大，各个部件分散，也不是商业项目，坑还是多~）</p>
<p>对于ROS、Mavros、Offboard模式还不清楚的小伙伴，先去补补相关概念，这里就不多做介绍了。</p>
<p><strong>注意</strong>：第一步和第二步只需要做一次，设置成功后，每次直接执行第三步。但如果修改了PX4固件，那你需要重新执行第一步。</p>
<p>第一步：<strong>编译</strong>。</p>
<p>cd ~/src/Firmware</p>
<p>make px4_sitl_default gazebo</p>
<p>第二步：<strong>source</strong>。了解ros功能包应该知道这一步是为了让系统知道有这个功能包存在，相当于设置环境变量，这样终端执行的时候就不会报找不到功能包的错误。</p>
<p><img src="https://pic2.zhimg.com/80/v2-edf5188525a2ea5f4b326b36d6ba99c5_720w.png" alt="img"></p>
<p>source Tools/setup_gazebo.bash $(pwd) $(pwd)/build/px4_sitl_default</p>
<p>export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:$(pwd)</p>
<p>export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:$(pwd)/Tools/sitl_gazebo</p>
<p>推荐大家手动source，打开终端输入gedit .bashrc。在弹出的txt文件最后一行，加入上述内容。值得注意的是，$(pwd)是要替换成对应的目录路径（PX4固件所在目录），我的路径是/home/fly_vision/px4_amov/Firmware（fly_vision是我的电脑名字，px4_amov是我存放固件的文件夹名字）。于是我的修改内容如下：</p>
<p>source /home/fly_vision/px4_amov/Firmware/Tools/setup_gazebo.bash /home/fly_vision/px4_amov/Firmware /home/fly_vision/px4_amov/Firmware/build/posix_sitl_default export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:/home/fly_vision/px4_amov/Firmware export ROS_PACKAGE_PATH=$ROS_PACKAGE_PATH:/home/fly_vision/px4_amov/Firmware/Tools/sitl_gazebo</p>
<p>第三步：<strong>运行Gazebo仿真</strong></p>
<p>roslaunch px4 posix_sitl.launch</p>
<p>因为会运行Gazebo，第一次启动会比较慢，耐心等待（如果报错，请关闭终端再次尝试，我的i5笔记本经常启动失败，这是你的笔记本提示你该花钱了的正常现象）。启动成功后，会看到Gazebo中有一个iris无人机。这时你可以打开QGC地面站，地面站会默认连接这台飞机，你可以尝试利用地面站发送起飞指令测试。</p>
<p>这个启动脚本位于Firmware/launch文件夹中，同时在此文件夹中，你还能看到其他类似的启动脚本。这里建议大家单独启动Mavros，而不是用它提供的另一个启动脚本同时启动（因为一个终端显示太多东西的话，报错你都看不到）。</p>
<p>第四步：<strong>运行Mavros</strong></p>
<p>roslaunch mavros px4.launch fcu_url:=”udp://:<a href="mailto:&#x31;&#52;&#x35;&#x34;&#x30;&#x40;&#49;&#x32;&#55;&#x2e;&#x30;&#46;&#48;&#x2e;&#x31;">&#x31;&#52;&#x35;&#x34;&#x30;&#x40;&#49;&#x32;&#55;&#x2e;&#x30;&#46;&#48;&#x2e;&#x31;</a>:14557”</p>
<p>此处我建议Mavros功能包使用二进制安装，比较省事。可以看到这里启动mavros时配置了一些端口参数（端口匹配才能成功连接），后续我会在PX4仿真模块中找到与之对应的参数配置。</p>
<p>尝试读取飞空的IMU数据，打开终端，输入</p>
<p>rostopic echo /mavros/imu/data</p>
<p>当然，除去imu消息，还有很多其他消息，可以使用下面指令查看都有哪些消息。</p>
<p>rostopic list</p>
<p>拓展：<a target="_blank" rel="noopener" href="https://www.freesion.com/article/42811010840/">https://www.freesion.com/article/42811010840/</a></p>
<p>实验：使用旧网卡；飞行试验</p>
<p>运行第一个文件后，rostopic echo /mavros/state</p>
<p>进行重规划实验中，生成的路径太靠近障碍物</p>
<h3 id="原代码复制过来运行mapping包的map-launch报错，具体为cv-bridge函数"><a href="#原代码复制过来运行mapping包的map-launch报错，具体为cv-bridge函数" class="headerlink" title="原代码复制过来运行mapping包的map.launch报错，具体为cv_bridge函数"></a>原代码复制过来运行mapping包的map.launch报错，具体为cv_bridge函数</h3><p>使用apt  install ros-melodic-cv-bridge安装的cv依赖opencv版本为4.1.1，库文件使用3.2.0</p>
<p>原来项目使用3.2.0，</p>
<p>需要更改cv的依赖版本（<a target="_blank" rel="noopener" href="https://blog.csdn.net/bigdog_1027/article/details/79092263%EF%BC%89%EF%BC%88https://blog.csdn.net/qinqinxiansheng/article/details/120219388%EF%BC%89%EF%BC%8C">https://blog.csdn.net/bigdog_1027/article/details/79092263）（https://blog.csdn.net/qinqinxiansheng/article/details/120219388），</a></p>
<p>首先编译安装opencv3.4.0（3.2.0版本死活不成功）</p>
<p>修改cv依赖的头文件和库文件</p>
<p>过程中还有vtk、flann（<a target="_blank" rel="noopener" href="https://blog.csdn.net/cs_terminal/article/details/117571998%EF%BC%89%E9%97%AE%E9%A2%98">https://blog.csdn.net/cs_terminal/article/details/117571998）问题</a></p>
<h2 id="vtk相关报错"><a href="#vtk相关报错" class="headerlink" title="vtk相关报错"></a>vtk相关报错</h2><p>The imported target “vtk” references the file<br>“/usr/bin/vtk”<br>but this file does not exist.  Possible reasons include:</p>
<ul>
<li>The file was deleted, renamed, or moved to another location.</li>
<li>An install or uninstall procedure did not complete successfully.</li>
<li>The installation package was faulty and contained<br>“/usr/lib/cmake/vtk-6.2/VTKTargets.cmake”<br>but not all the files it references.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>只是由于在Ubuntu下使用的是vtk6造成的<br>在终端中输入该命令：</li>
</ul>
<p>sudo ln -s /usr/bin/vtk6 /usr/bin/vtk</p>
<h2 id="致命错误：Eigen-Dense：没有那个文件或目录"><a href="#致命错误：Eigen-Dense：没有那个文件或目录" class="headerlink" title="致命错误：Eigen/Dense：没有那个文件或目录"></a>致命错误：Eigen/Dense：没有那个文件或目录</h2><p>实际就是编译器找不到这个头文件了，首先要看看是不是已经安装了Eigen3（在/usr/local/include或者/usr/include目录）.</p>
<p>如果没有，到官网下载一个,解压到/usr/local/include或者/usr/include目录<br>官网：<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/index.php?title=Main_Page">http://eigen.tuxfamily.org/index.php?title=Main_Page</a></p>
<p>或者通过apt安装：sudo apt-get install libeigen3-dev</p>
<p>安装完成后，编译器会去/usr/local/include或者/usr/include目录找头文件，但找到的是eigen3，并没有Eigen和unsupported，所以需要建立一个软连接链接到这两个文件夹即可</p>
<p>#要先确定你的Eigen3安装在/usr/local/include还是/usr/include<br>cd /usr/include<br>sudo ln -sf eigen3/Eigen Eigen<br>sudo ln -sf eigen3/unsupported unsupported</p>
<p>结果 运行map.launch 无报错，进行下一步</p>
<h3 id="运行macros-包下的px4-launch报错"><a href="#运行macros-包下的px4-launch报错" class="headerlink" title="运行macros 包下的px4.launch报错"></a>运行macros 包下的px4.launch报错</h3><p>1.更改mavros版本从1.3到1.10 没用</p>
<p>2.更改gazebo版本从9.0到9.19没用</p>
<p>2022.5.10<br>使用viewer查看相机没问题，<br>使用rviz查看d455 深度图、image没有<br>    查看t265image没有（怀疑rviz）</p>
<p>使用apt install ros-melodic-realsense2-camera<br>apt install ros-melodic-rviz<br>455点云图可以看到<br>修改launch相关参数 image可以看到</p>
<p>相机launch文件参数意义：<br><a target="_blank" rel="noopener" href="http://zhaoxuhui.top/blog/2020/09/25/intel-realsense-D435i-ROS-API-notes.html">http://zhaoxuhui.top/blog/2020/09/25/intel-realsense-D435i-ROS-API-notes.html</a></p>
<p>在rs_camera.launch文件中找到unite_imu_method这个参数，把它的值可以设置为copy或者linear_interpolation，这样再次启动rs_camera节点启动D435i就可以在Topic列表里看到/camera/imu这个Topic了</p>
<p>Theora是一种开放而且免费的视频压缩编码技术</p>
<p>带有rect的Topic是表示校正后的数据，Rectify的缩写。</p>
<p>2022.5.11<br>目标：在tx2无人机上安装librealsense sdk，运行mapping map.launch<br>15.30 检查原有建图情况<br>16.00 开始<br>sdk版本3.35.2    d435i firmware 5.12.02.00  摄像头都能找到3.1/2</p>
<p>升级realsense sdk到2.5.0，t265能找到，435i，455找不到<br>在妙算上升级435i最新固件后，还是找不到，重装sdk后不行</p>
<p>tx2系统配置：<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15357586/3788162">https://blog.51cto.com/u_15357586/3788162</a><br>L4T版本：<br>    # R32 (release), REVISION: 7.1, GCID: 29818004, BOARD: t186ref, EABI: aarch64, DATE: Sat Feb 19 17:07:00 UTC 2022<br>系统版本：<br>    DISTRIB_ID=Ubuntu<br>    DISTRIB_RELEASE=18.04<br>    DISTRIB_CODENAME=bionic<br>    DISTRIB_DESCRIPTION=”Ubuntu 18.04.6 LTS”<br>内核版本：<br>    Linux nvidia 4.9.253-tegra #1 SMP PREEMPT Sat Feb 19 08:58:27 PST 2022 aarch64 aarch64 aarch64 GNU/Linux<br>jetpack版本：<br>    （sudo apt-cache show nvidia-jetpack）<br>    Version: 4.4.1-b50</p>
<p>TensorRT版本：<br>    无<br>CUDA版本：<br>    CUDA Version 10.2.300<br>OPENCV版本：<br>    3.4.0 </p>
<p>飞机tx2的系统配置：<br>L4T版本：<br>    # R32 (release), REVISION: 4.3, GCID: 21589087, BOARD: t186ref, EABI: aarch64, DATE: Fri Jun 26 04:34:27 UTC 2020<br>系统版本：<br>    DISTRIB_ID=Ubuntu<br>    DISTRIB_RELEASE=18.04<br>    DISTRIB_CODENAME=bionic<br>    DISTRIB_DESCRIPTION=”Ubuntu 18.04.4 LTS”</p>
<p>内核版本：<br>    Linux nv-tx2 4.9.140-tegra #5 SMP PREEMPT Mon Sep 28 11:50:37 CST 2020 aarch64 aarch64 aarch64 GNU/Linux<br>jetpack版本：<br>    （sudo apt-cache show nvidia-jetpack）<br>    Version: 4.6.1-b110</p>
<p>TensorRT版本：<br>    7.1.3-1+cuda10.2<br>CUDA版本：<br>    CUDA Version 10.2.89<br>OPENCV版本：<br>    3.4.3</p>
<p>怀疑内核不匹配，相关网页：<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15127579/4566554">https://blog.51cto.com/u_15127579/4566554</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/TengYun_zhang/article/details/90452856">https://blog.csdn.net/TengYun_zhang/article/details/90452856</a></p>
<p>sudo apt-get install  libglew-dev  <br>    libtiff5-dev<br>    zlib1g-dev<br>    libjpeg-dev<br>    libpng12-dev \<br>    libjasper-dev \<br>    libavcodec-dev \<br>    libavformat-dev \<br>    libavutil-dev \<br>    libpostproc-dev \<br>    libswscale-dev \<br>    libeigen3-dev \<br>    libtbb-dev \<br>    libgtk2.0-dev \<br>    pkg-config  </p>
<p>TX2共两块CPU，和一块有256个CUDA核心的GPU。CPU一块是双核的丹佛二，第二快是ARM CortexA57。8G的运行内存，32G flash存储器</p>
<p>剩下两核的驱动问题：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/JanKin_BY/article/details/120441238">https://blog.csdn.net/JanKin_BY/article/details/120441238</a><br>将/boot/extlinux/exltinux.conf 文件里的isolcpus=1-2修改为isolcpus=</p>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD<br>重启<br>=======<br>重启</p>
<p>nx安装系统<br>nx载板型号：RTSO-6002/E    （tx2载板型号 RTSO-9002U）<br>nx l4t 32.7.1</p>
<p>opencv依赖包安装</p>
<p>sudo apt install libjasper1 libjasper-dev</p>
<p>报错：</p>
<p>使用《Xavier NX安装opencv3.4.7》里说的解决方法~不行：</p>
<p>新的解决方法：</p>
<p>1.sudo gedit /etc/apt/sources.list</p>
<p>2.在sources.list文件最后面 添加：</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial main multiverse restricted universe<br>deb <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-security main multiverse restricted universe<br>deb <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-updates main multiverse restricted universe<br>deb <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-backports main multiverse restricted universe<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial main multiverse restricted universe<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-security main multiverse restricted universe<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-updates main multiverse restricted universe<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/">http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/</a> xenial-backports main multiverse restricted universe<br>————————————————<br>版权声明：本文为CSDN博主「佛前一朵莲」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ysten618/article/details/120082709">https://blog.csdn.net/ysten618/article/details/120082709</a></p>
<p>eigen3</p>
<p>1.查看当前版本<br>pkg-config –modversion eigen3<br>1<br>会返回版本号</p>
<p>2.删除eigen3相关文件<br>查看eigen3位置</p>
<p>sudo updatedb<br>locate eigen3<br>1<br>2<br>删除eigen3相关文件</p>
<p>sudo rm -rf /usr/include/eigen3<br>sudo rm -rf /usr/lib/cmake/eigen3<br>sudo rm -rf /usr/local/include/eigen3<br>sudo rm -rf /usr/share/doc/libeigen3-dev<br>sudo rm -rf /usr/local/share/pkgconfig/eigen3.pc /usr/share/pkgconfig/eigen3.pc /var/lib/dpkg/info/libeigen3-dev.list /var/lib/dpkg/info/libeigen3-dev.md5sums<br>sudo rm -rf /usr/local/lib/pkgconfig/eigen3.pc<br>sudo rm -rf /usr/local/share/eigen3<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>刷新查看是否删除彻底</p>
<p>sudo updatedb<br>locate eigen3<br>————————————————</p>
<p>b529b390-29d7-40a6-992e-94f23aa63ae3   sd卡 partid</p>
<p>没安装opencv自己有版本4.1.1，是nvidia自带还是ros安装的</p>
<h1 id="Project-‘cv-bridge‘-specifies-‘-usr-include-opencv‘-as-an-include-dir-which-is-not-found-的解决方法"><a href="#Project-‘cv-bridge‘-specifies-‘-usr-include-opencv‘-as-an-include-dir-which-is-not-found-的解决方法" class="headerlink" title="Project ‘cv_bridge‘ specifies ‘/usr/include/opencv‘ as an include dir, which is not found.的解决方法"></a>Project ‘cv_bridge‘ specifies ‘/usr/include/opencv‘ as an include dir, which is not found.的解决方法</h1><p>这不是因为我们编写的程序有误，而是NVIDIA的32.3.1image自带的是opencv4版本，把opencv命名成了opencv4</p>
<p>修改方法：只需修改上述路径中的cv_bridgeconfig.cmke文件，将100行附近的两个opencv改成opencv4即可（注意，只需要改动单独一个的opencv,前面有连字符的opencv不需要改动）</p>
<p>注意：如果jetson nano的版本自带的opencv是3版本，可能不会出现此问题</p>
<h1 id="cmake编译原理是需要CMakeLists-txt找到-cmake-文件"><a href="#cmake编译原理是需要CMakeLists-txt找到-cmake-文件" class="headerlink" title="cmake编译原理是需要CMakeLists.txt找到 .cmake 文件"></a>cmake编译原理是需要CMakeLists.txt找到 .cmake 文件</h1><p>所以我在/usr/share/OpenCV/ 目录下找到了OpenCVConfig.cmake，现在只需要在功能包里的CMakeLists.txt中find_package前加入：<br>set(OpenCV_DIR /usr/share/OpenCV/)</p>
<h1 id="opencv多版本安装"><a href="#opencv多版本安装" class="headerlink" title="opencv多版本安装"></a>opencv多版本安装</h1><blockquote>
<p>对于在ubuntu下开发CV程序的小伙伴们,难免会遇到不同程序要使用不同版本opencv的情况.使用python进行开发工作还可以用Anaconda去切换环境,但是使用C++进行开发时就必须要考虑到在同一环境中如何安装多版本的Opencv了.<br>在我的电脑上,同时安装了opencv3.4和opencv4.1,下面来说说如何安装两个版本,并且交换使用.</p>
<p>假设你电脑上已经安装过一个版本的opencv了<br>若你仍未安装opencv,可以根据一下链接进行opencv的安装:Opencv安装教程</p>
<ol>
<li>照常从opencv官网中下载另一版本的opencv</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://opencv.org/releases/">https://opencv.org/releases/</a><br>1<br>2) 照常尽情地在新版本的opencv的目录中使用一下命令:</p>
<p>mkdir build<br>cd build<br>1<br>2<br>3) 但是使用cmake安装新版本的opencv时,我们需要修改其安装的路径(prefix),否则照常安装的话会把之前版本的opencv覆盖,因为我们opencv是默认安装在/usr/local/中.</p>
<p>在/usr/local/下新建一个文件夹,文件夹名为opencv340.而后cmake的命令如下:<br>cmake .. -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/usr/local/opencv340<br>1<br>2<br>cmake过后,我们会发现在/usr/local/opencv340中出现bin,lib,share,include的文件夹.</p>
<ol start="4">
<li>回到build目录中,执行如下命令</li>
</ol>
<p>sudo make -j4(自信点的话-j16,-j32也行)<br>=====漫长的编译等待后======祝你成功=======<br>sudo make install<br>1<br>2<br>3<br>5) 安装完成了,然后剩下环境的配置,执行如下的命令</p>
</blockquote>
<p>（x86下的文件名  x86_64-linux-gnu.conf）</p>
<blockquote>
<p>sudo gedit /etc/ld.so.conf.d/aarch64-linux-gnu.conf (我安装的opencv4.1)<br>在里面加入下面这行<br>/usr/local/opencv340/lib<br>然后命令执行<br>sudo ldconfig  //使得刚才的环境配置生效<br>1<br>2<br>3<br>4<br>5<br>6) 又到了愉快地修改环境变量环节,粗暴点,把新版本的opencv的PATH,PKG_CONFIG_PATH,LD_LIBRARY_PATH都加入到环境变量中.(要注意你当前的用户是root还是你自己的账户,配置的时候不要搞错了.如果在root下配置了以下的环境变量,那么在你自己的账户下是不会生效的)</p>
<p>vim <del>/.bashrc<br>底部加入三条命令<br>export PATH=”</del>/Downloads/opencv-3.4.0/build/bin:$PATH”<br>export PKG_CONFIG_PATH=”/usr/local/opencv340/lib/pkgconfig:$PKG_CONFIG_PATH”<br>export LD_LIBRARY_PATH=”/usr/local/opencv340/lib:$LD_LIBRARY_PATH”<br>1<br>2<br>3<br>4<br>5<br>7) 配置完成后source激活一下,重启你的终端或者vscode啥的,环境激活后opencv就变成了新的版本的了.如果想用回旧版本的opencv只需要再次修改环境变量,把上面三条命令注释再source一下就好</p>
</blockquote>
<p>查看opencv版本<br>pkg-config –modversion opencv<br>完了把cv_bridge的cmake的opencv路径改了</p>
<h1 id="cv——bridge寻找opencv版本语句位置"><a href="#cv——bridge寻找opencv版本语句位置" class="headerlink" title="cv——bridge寻找opencv版本语句位置"></a>cv——bridge寻找opencv版本语句位置</h1><blockquote>
<p>在学习jetson nano时，在编译ROS的package时可能会出现cmake的错误：<br>Project ‘cv_bridge’ specifies ‘/usr/include/opencv’ as an include dir, which is not found.</p>
<p>这不是因为我们编写的程序有误，而是NVIDIA的32.3.1image自带的是opencv4版本，把opencv命名成了opencv4</p>
<p>修改方法：只需修改上述路径中的cv_bridgeconfig.cmke文件，将100行附近的两个opencv改成opencv4即可（注意，只需要改动单独一个的opencv,前面有连字符的opencv不需要改动）</p>
<p>注意：如果jetson nano的版本自带的opencv是3版本，可能不会出现此问题</p>
</blockquote>
<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
<h1 id="上午好好的，下午进不去系统"><a href="#上午好好的，下午进不去系统" class="headerlink" title="上午好好的，下午进不去系统"></a>上午好好的，下午进不去系统</h1><blockquote>
<p>error during i2c read probe board setup failed</p>
</blockquote>
<h1 id="烧录系统"><a href="#烧录系统" class="headerlink" title="烧录系统"></a>烧录系统</h1><ol>
<li><p>选择瑞泰镜像，不能用官方镜像<br>检查方法  dmesg | grep dts<br>显示 <img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/845ce1590e47021e7b37c4bc595896c.jpg">  为官方</p>
</li>
<li><p>bsp选择nx目录下，不要选择32.7.1目录下</p>
</li>
<li><p>目前的uuidpart    d3b71f11-043d-484e-ae7d-206760bceada</p>
</li>
<li><p>烧录手册版本选择1.1</p>
</li>
<li><p>烧录外部启动系统时<br>选择external 会报找不到对应uuid的错误<br>需要写入mmcblk1怕</p>
</li>
<li><p>sdkmanager<br>安装cuda dnn 不用他，试了几遍都不成功</p>
</li>
<li><p>从sd卡启动手册选择版本1.1</p>
</li>
<li><p>jtop安装<br>sudo apt install python3-pip<br>sudo -H pip3 install -U jetson-stats<br>sudo systemctl restart jetson_stats.service<br>reboot</p>
</li>
</ol>
<h1 id="ceres-安装"><a href="#ceres-安装" class="headerlink" title="ceres 安装"></a>ceres 安装</h1><p>安装依赖<br>sudo apt-get install -y google-mock libboost-all-dev  libeigen3-dev libgflags-dev libgoogle-glog-dev liblua5.2-dev libprotobuf-dev  libsuitesparse-dev libwebp-dev ninja-build protobuf-compiler python-sphinx  ros-melodic-tf2-eigen libatlas-base-dev libsuitesparse-dev liblapack-dev</p>
<p>download<br><a target="_blank" rel="noopener" href="https://github.com/ceres-solver/ceres-solver/releases">https://github.com/ceres-solver/ceres-solver/releases</a></p>
<p>compile<br>mkdir build<br>cd build<br>cmake …<br>make -j6<br>sudo make install<br>=======</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>9fe0423c3a24031c913d166b3ac7ff3ebdfc73d8<br>3d419ebd75fa478d0e144fedfe1049e3bc140131</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="安装软件包"><a href="#安装软件包" class="headerlink" title="安装软件包"></a>安装软件包</h1><p>型号：Xavier nx</p>
<p>l4t版本和jetpack版本对应关系</p>
<blockquote>
<ul>
<li>JetPack 4.6.1<ul>
<li>Jetson Xavier NX Series, Jetson TX2 Series, Jetson AGX Xavier Series, Jetson Nano, Jetson TX1 [<a target="_blank" rel="noopener" href="https://developer.nvidia.com/embedded/linux-tegra-r3271">L4T 32.7.1</a>]</li>
<li><a target="_blank" rel="noopener" href="https://developer.nvidia.com/embedded/jetpack-archive">https://developer.nvidia.com/embedded/jetpack-archive</a></li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="第一次失败"><a href="#第一次失败" class="headerlink" title="第一次失败"></a>第一次失败</h2><p>，opencv on target 下载不动，国内国外网站均能访问</p>
<p><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/QQ%E5%9B%BE%E7%89%8720221012191550.png"></p>
<p><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/QQ%E5%9B%BE%E7%89%8720221012191603.png"></p>
<h2 id="E-Sub-process-usr-bin-dpkg-returned-an-error-code-1"><a href="#E-Sub-process-usr-bin-dpkg-returned-an-error-code-1" class="headerlink" title="E: Sub-process /usr/bin/dpkg returned an error code (1)"></a>E: Sub-process /usr/bin/dpkg returned an error code (1)</h2><blockquote>
<p>$ sudo mv /var/lib/dpkg/info/ /var/lib/dpkg/info_old/<br>$ sudo mkdir /var/lib/dpkg/info/<br>$ sudo apt-get update<br>$ sudo apt-get -f install<br>$ sudo mv /var/lib/dpkg/info/* /var/lib/dpkg/info_old/<br>$ sudo rm -rf /var/lib/dpkg/info<br>$ sudo mv /var/lib/dpkg/info_old/ /var/lib/dpkg/info/</p>
</blockquote>
<h2 id="GPG-error-file-var-cuda-repo-l4t-10-2-local-Release-The-following-signatures-couldn’t-be-verified-because-the-public-key-is-not-available-NO-PUBKEY-F60F4B3D7FA2AF80"><a href="#GPG-error-file-var-cuda-repo-l4t-10-2-local-Release-The-following-signatures-couldn’t-be-verified-because-the-public-key-is-not-available-NO-PUBKEY-F60F4B3D7FA2AF80" class="headerlink" title="GPG error: file:/var/cuda-repo-l4t-10-2-local  Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY F60F4B3D7FA2AF80"></a>GPG error: file:/var/cuda-repo-l4t-10-2-local  Release: The following signatures couldn’t be verified because the public key is not available: NO_PUBKEY F60F4B3D7FA2AF80</h2><blockquote>
<ol>
<li>sudo apt-key adv –keyserver keyserver.ubuntu.com –recv-keys F60F4B3D7FA2AF80</li>
<li>sudo apt-get update &amp;&amp; sudo apt-get check</li>
</ol>
</blockquote>
<h2 id="Could-not-handshake-The-TLS-connection-was-non-properly-terminated-IP-127-0-0-1-12333"><a href="#Could-not-handshake-The-TLS-connection-was-non-properly-terminated-IP-127-0-0-1-12333" class="headerlink" title="Could not handshake: The TLS connection was non-properly terminated. [IP: 127.0.0.1 12333]"></a>Could not handshake: The TLS connection was non-properly terminated. [IP: 127.0.0.1 12333]</h2><p>把源从https改为http</p>
<h2 id="仓库不在提供发布源"><a href="#仓库不在提供发布源" class="headerlink" title="仓库不在提供发布源"></a>仓库不在提供发布源</h2><p>开启代理后apt使用配置文件apt.conf中将https走了https代理</p>
<p>在etc/apt/apt.conf中去掉https的s</p>
<p>换源</p>
<p>换网络</p>
<h2 id="multimedia-安装失败，其他成功"><a href="#multimedia-安装失败，其他成功" class="headerlink" title="multimedia 安装失败，其他成功"></a>multimedia 安装失败，其他成功</h2><blockquote>
<p>BSP Version Mismatch 报错</p>
</blockquote>
<h2 id="px4结合mocap动作捕捉系统"><a href="#px4结合mocap动作捕捉系统" class="headerlink" title="px4结合mocap动作捕捉系统"></a>px4结合mocap动作捕捉系统</h2><p>github页面教学<br><a target="_blank" rel="noopener" href="https://github.com/potato77/Amovlab_opensource/tree/master/px4_pos_estiamtor">https://github.com/potato77/Amovlab_opensource/tree/master/px4_pos_estiamtor</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42879437/article/details/117514082">https://blog.csdn.net/qq_42879437/article/details/117514082</a><br>飞控中如何设置</p>
<p>为了配合机载电脑中传来的定位信息，有两个和ekf2有关的参数需要修改。</p>
<p>EKF2_AID_MASK 设置为24（即勾选vision position fusion and vision yaw fusion）<br>EKF2_HGT_MODE 设置为VISION （默认为气压计）<br>因为ekf2中默认是不会融合这个外部的定位信息的，这里相当于在ekf2中启用这个功能。至于ekf2参数中还有很多和这个外部定位相关的滤波参数设置，就请参看官网教程吧。我没有改任何参数，但是ekf2代码的话，阿木团队优化过，具体修改笔者也不清楚。</p>
<p>其他说明：</p>
<p>做了以上修改之后，水平校准会遇到问题，所以要修改之前校准水平。<br>修改之后，自稳模式会变得有些奇怪，基本上只能使用位置闭环的控制模式了，也就是offboard模式。<br>”<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/101967658?from_voters_page=true%E2%80%9C">https://zhuanlan.zhihu.com/p/101967658?from_voters_page=true“</a></p>
<h3 id="fix-frame"><a href="#fix-frame" class="headerlink" title="fix frame"></a>fix frame</h3><p>rosrun tf static_transform_publisher 0.0 0.0 0.0 0.0 0.0 0.0 map xxx 100<br>rosrun rqt_tf_tree rqt_tf_tree </p>
<h3 id="rviz-主界面面板说明"><a href="#rviz-主界面面板说明" class="headerlink" title="rviz 主界面面板说明"></a>rviz 主界面面板说明</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ben_xiao_hai_123/article/details/109258584">https://blog.csdn.net/ben_xiao_hai_123/article/details/109258584</a></p>
<h3 id="rviz-中文安装-自定义rviz"><a href="#rviz-中文安装-自定义rviz" class="headerlink" title="rviz 中文安装 自定义rviz"></a>rviz 中文安装 自定义rviz</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhang6318/article/details/117964672">https://blog.csdn.net/zhang6318/article/details/117964672</a></p>
<p>安装colcon<br>sudo apt install python3-colcon-common-extensions</p>
<h3 id="动捕坐标系和相机世界坐标系位置、姿态转换"><a href="#动捕坐标系和相机世界坐标系位置、姿态转换" class="headerlink" title="动捕坐标系和相机世界坐标系位置、姿态转换"></a>动捕坐标系和相机世界坐标系位置、姿态转换</h3><p>相机内外参、像素坐标系、世界坐标系<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/389653208">https://zhuanlan.zhihu.com/p/389653208</a><br>世界坐标系的方向定义：单目 选第一帧的相机坐标系的方向定义（即右下前）<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/346131786/?utm_id=0">https://zhuanlan.zhihu.com/p/346131786/?utm_id=0</a><br>imu坐标系（左手，右前上）、<br><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/20221019131012.png"><br>坐标系姿态（四元数）转换<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/muzigef/article/details/103650811">https://blog.csdn.net/muzigef/article/details/103650811</a></p>
<h2 id="xavier-NX-烧录系统"><a href="#xavier-NX-烧录系统" class="headerlink" title="xavier NX 烧录系统"></a>xavier NX 烧录系统</h2><ol>
<li><p>准备驱动包、根文件系统、realtimesBSP</p>
<p>在188虚拟机shaolu目录下已有，版本32.7.1(或者台式机下载-压缩-shaolu下)</p>
</li>
<li><p>烧录步骤，严格按照指令进行，注意sudo有无和tar的命令参数，直到有success</p>
<p><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/%E6%AD%A5%E9%AA%A4.png"></p>
</li>
<li><p>烧录参数 rtso-6002 mmcblk0p1</p>
<p>sudo ./flash.sh rtso-6002 mmcblk0p1</p>
</li>
</ol>
<h2 id="XAVIER-NX-从SD卡启动"><a href="#XAVIER-NX-从SD卡启动" class="headerlink" title="XAVIER NX 从SD卡启动"></a>XAVIER NX 从SD卡启动</h2><ol>
<li>partuuid</li>
</ol>
<p>31919bfc-57e5-494f-b941-1c6782a7bf60</p>
<ol start="2">
<li>dd命令 </li>
</ol>
<p>sudo dd if=/dev/foo bs=4M | pv -s 20G | sudo dd of=/dev/baz bs=4M</p>
<ol start="3">
<li>flush刷的时候出现can not find partuuid </li>
</ol>
<blockquote>
<p>sudo ./flash.sh rtso-6002 mmcblk1p1 而不是external</p>
</blockquote>
<ol start="4">
<li>故障是不是光重新刷sd卡就可以</li>
</ol>
<h2 id="source一个工作空间把另一个也source"><a href="#source一个工作空间把另一个也source" class="headerlink" title="source一个工作空间把另一个也source"></a>source一个工作空间把另一个也source</h2><p>真恶心，<br>编辑devel下的setup util.py文件<br>修改export 变量  export ros_packet_path=”aaaa”</p>
<h2 id="ros下各个地图"><a href="#ros下各个地图" class="headerlink" title="ros下各个地图"></a>ros下各个地图</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_16643223/article/details/113923203">https://blog.csdn.net/sinat_16643223/article/details/113923203</a></p>
<h2 id="tf的介绍"><a href="#tf的介绍" class="headerlink" title="tf的介绍"></a>tf的介绍</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sxy370921/p/11726691.html">https://www.cnblogs.com/sxy370921/p/11726691.html</a></p>
<h2 id="ros-launch-参数"><a href="#ros-launch-参数" class="headerlink" title="ros launch 参数"></a>ros launch 参数</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/157526418">https://zhuanlan.zhihu.com/p/157526418</a><br>全局参数和局部参数，更好 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u013528298/article/details/87937555">https://blog.csdn.net/u013528298/article/details/87937555</a><br>fp_my-ws的地图生成参数还是不理解，报错Unknown substitution command [random_or_load]. Valid commands are [‘find’, ‘env’, ‘optenv’, ‘dirname’, ‘anon’, ‘arg’]</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/04/18/Port-Swigger%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/04/18/Port-Swigger%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Port_Swigger学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-04-18 10:04:03 / 修改时间：10:25:40" itemprop="dateCreated datePublished" datetime="2022-04-18T10:04:03+08:00">2022-04-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="检索隐藏数据"><a href="#检索隐藏数据" class="headerlink" title="检索隐藏数据"></a>检索隐藏数据</h2><p>考虑一个显示不同类别产品的购物应用程序。当用户点击礼物类别时，他们的浏览器会请求 URL：</p>
<pre><code>https://insecure-website.com/products?category=Gifts
</code></pre>
<p>这会导致应用程序进行 SQL 查询以从数据库中检索相关产品的详细信息：</p>
<pre><code>SELECT * FROM products WHERE category = &#39;Gifts&#39; AND released = 1
</code></pre>
<p>此 SQL 查询要求数据库返回：</p>
<ul>
<li>所有详细信息 (*)</li>
<li>从产品表</li>
<li>其中类别是礼物</li>
<li>并释放为 1。</li>
</ul>
<p>该限制<code>released = 1</code>用于隐藏未发布的产品。对于未发布的产品，大概是<code>released = 0</code>.</p>
<p>该应用程序没有实施任何针对 SQL 注入攻击的防御措施，因此攻击者可以构建如下攻击：</p>
<pre><code>https://insecure-website.com/products?category=Gifts&#39;--
</code></pre>
<p>这将导致 SQL 查询：</p>
<pre><code>SELECT * FROM products WHERE category = &#39;Gifts&#39;--&#39; AND released = 1
</code></pre>
<p>这里的关键是双破折号序列<code>--</code>是 SQL 中的注释指示符，意味着查询的其余部分被解释为注释。这有效地删除了查询的其余部分，因此它不再包括<code>AND released = 1</code>. 这意味着显示所有产品，包括未发布的产品。</p>
<p>更进一步，攻击者可以使应用程序显示任何类别的所有产品，包括他们不知道的类别：</p>
<pre><code>https://insecure-website.com/products?category=Gifts&#39;+OR+1=1--
</code></pre>
<p>这将导致 SQL 查询：</p>
<pre><code>SELECT * FROM products WHERE category = &#39;Gifts&#39; OR 1=1--&#39; AND released = 1
</code></pre>
<p>修改后的查询将返回类别为礼物或 1 等于 1 的所有项目。由于<code>1=1</code>始终为真，因此查询将返回所有项目。</p>
<h2 id="颠覆应用逻辑"><a href="#颠覆应用逻辑" class="headerlink" title="颠覆应用逻辑"></a>颠覆应用逻辑</h2><p>考虑一个允许用户使用用户名和密码登录的应用程序。如果用户提交用户名<code>wiener</code>和密码<code>bluecheese</code>，应用程序通过执行以下 SQL 查询来检查凭据：</p>
<pre><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;
</code></pre>
<p>如果查询返回用户的详细信息，则登录成功。否则，它被拒绝。</p>
<p>在这里，攻击者只需使用 SQL 注释序列从查询子句中<code>--</code>删除密码检查，即可以任何没有密码的用户身份登录。<code>WHERE</code>例如，提交用户名<code>administrator&#39;--</code>和空白密码会导致以下查询：</p>
<pre><code>SELECT * FROM users WHERE username = &#39;administrator&#39;--&#39; AND password = &#39;&#39;
</code></pre>
<p>此查询返回用户名是的用户，<code>administrator</code>并成功地将攻击者作为该用户登录。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/04/08/doc2vec%E4%B8%8E%E8%81%9A%E7%B1%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/04/08/doc2vec%E4%B8%8E%E8%81%9A%E7%B1%BB/" class="post-title-link" itemprop="url">doc2vec与聚类</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-08 19:14:38" itemprop="dateCreated datePublished" datetime="2022-04-08T19:14:38+08:00">2022-04-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-04-29 15:40:24" itemprop="dateModified" datetime="2022-04-29T15:40:24+08:00">2022-04-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Word2vec"><a href="#Word2vec" class="headerlink" title="Word2vec"></a>Word2vec</h2><h3 id="1-Word2Vec是用来生成词向量的工具"><a href="#1-Word2Vec是用来生成词向量的工具" class="headerlink" title="1.Word2Vec是用来生成词向量的工具"></a>1.Word2Vec是用来生成词向量的工具</h3><h3 id="2词向量（https-zhuanlan-zhihu-com-p-81032021）"><a href="#2词向量（https-zhuanlan-zhihu-com-p-81032021）" class="headerlink" title="2词向量（https://zhuanlan.zhihu.com/p/81032021）"></a>2词向量（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/81032021%EF%BC%89">https://zhuanlan.zhihu.com/p/81032021）</a></h3><h4 id="2-1字典序"><a href="#2-1字典序" class="headerlink" title="2.1字典序"></a>2.1字典序</h4><p>​    含义：词典中的第几个字</p>
<p>​    <img src="https://pic1.zhimg.com/80/v2-3c9a38cc5722f46beffcc10470237768_720w.jpg" alt="img"></p>
<h4 id="2-2one-hot编码"><a href="#2-2one-hot编码" class="headerlink" title="2.2one-hot编码"></a>2.2one-hot编码</h4><p>​    构建一个由 n个0组成的序列 (n是字典总数)，其中将第字典序个0 换成 1</p>
<p>​    例如：n =3，则所有的字典序对应one-hot 编码有</p>
<pre><code class="text">1: 1 , 0 , 0
2: 0 , 1 , 0
3: 0 , 0 , 1
</code></pre>
<p><img src="https://pic1.zhimg.com/80/v2-e1a97fadf10aaf6e62a5f2ed807800d4_720w.jpg" alt="img"></p>
<h4 id="2-3深度学习的本质"><a href="#2-3深度学习的本质" class="headerlink" title="2.3深度学习的本质"></a>2.3深度学习的本质</h4><p>​    给定大量级样本及模型（负杂函数），求解模型参数（函数解析式）<img src="https://pic2.zhimg.com/80/v2-c79467c3bc8e519b67f720924d3874f1_720w.jpg" alt="img"></p>
<p>​    简单来说深度学习，就是通过待定系数法、求导更新，最小化模型和真实世界模型的误差。其中模型就是：一大堆负杂的矩阵乘法、加法及变换</p>
<h4 id="2-4embedding"><a href="#2-4embedding" class="headerlink" title="2.4embedding"></a>2.4embedding</h4><p>​    既然已经有了 one-hot 来表达文本，那么为什么还需要词向量呢？</p>
<p>​    让我们做一个假设，通过 one-hot 我们可以对APP上的外卖店都编了一个号。仅通过这个编号我们可以知道每家店的口味吗？答案是否定的，因为单独的one-hot 编码仅仅只代表了一个无意义的编码。</p>
<p>​    人类为了对未知的事物进行描述，会通过事物的其他方向来进行类比。就像我们会将外卖按照：口味、速度、价格、好评等等维度进行打分，以此希望能够通过这些维度的评分来体现这家外卖的好坏。</p>
<p>​    因此，embedding可以抽象的理解为：为了让one-hot 具有更强的语义特征而设计的描述one-hot不同维度的特征。只不过这个维度和特征是通过某种形式学习得到。</p>
<h4 id="2-5目标任务"><a href="#2-5目标任务" class="headerlink" title="2.5目标任务"></a>2.5目标任务</h4><p>​    首先，看看nlp embedding 的鼻祖之一：word2vec (2013)</p>
<p><img src="https://pic1.zhimg.com/80/v2-3d7e19c00358605c893e51d666327284_720w.png" alt="img"></p>
<p>​    直观的来讲，word2vec 就是进一步在语言的算法表达上，做了一个映射任务：</p>
<p>​    语言 ——&gt; 函数 ——&gt; 目标任务</p>
<p>​    目标任务有两种做法 :</p>
<ol>
<li>skip-gram : 给定句子中的当前词，预测周围的词</li>
<li>cbow : 给定句子中的周围词，预测当前词</li>
</ol>
<p><img src="https://pic2.zhimg.com/80/v2-3677468e93f3ed0b1b15244a39373e51_720w.jpg" alt="img"></p>
<p>​    其核心观点是在one-hot 的文本表征基础上，乘以一个参数矩阵，得到一个dim 长度的参数，这个就是embedding</p>
<p>​    因为该矩阵通过Skip-gram 或 CBOW 方式在大量语料中训练得到 ， 所以，通过w2c训练得到的embedding 也就带有了相似词相近这么一个特点。</p>
<p>​    因为同义词、近义词可能在大量语料上有着相同的上下文，因此，训练后embedding 也相近</p>
<blockquote>
<p>w2c 提供了一种有效的文本数值化方法，为深度学习发展提供了标准范式</p>
</blockquote>
<p>w2c 的本质是通过embedding 的方式，将原有的one-hot 矩阵通过大量的语料扩展出了dim 维度的特征信息。</p>
<p><img src="https://pic4.zhimg.com/80/v2-564acd6b926af536a9abcc2739b5b85f_720w.jpg" alt="img"></p>
<p>就像我们给大众店家打分一样，本来店家可能只是 某地区、第几家 店铺。</p>
<p>通过5个维度，给店家打了一个评分，这个评分一定意义上就能代表这个店家。</p>
<h2 id="Doc2vec"><a href="#Doc2vec" class="headerlink" title="Doc2vec"></a>Doc2vec</h2><h2 id="（https-zhuanlan-zhihu-com-p-136096645）"><a href="#（https-zhuanlan-zhihu-com-p-136096645）" class="headerlink" title="（https://zhuanlan.zhihu.com/p/136096645）"></a>（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/136096645%EF%BC%89">https://zhuanlan.zhihu.com/p/136096645）</a></h2><p>Doc2vec可以获得句子、段落和文档的向量表达，是Word2Vec的拓展。</p>
<p>代码</p>
<h2 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h2><h3 id="1聚类（https-zhuanlan-zhihu-com-p-104355127）"><a href="#1聚类（https-zhuanlan-zhihu-com-p-104355127）" class="headerlink" title="1聚类（https://zhuanlan.zhihu.com/p/104355127）"></a>1聚类（<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104355127%EF%BC%89">https://zhuanlan.zhihu.com/p/104355127）</a></h3><p><code>聚类(Clustering)</code>是按照某个特定标准(如距离)把一个数据集分割成不同的类或簇，使得<strong>同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大</strong>。也即聚类后同一类的数据尽可能聚集到一起，不同类数据尽量分离。</p>
<h4 id="1-1-聚类的一般过程"><a href="#1-1-聚类的一般过程" class="headerlink" title="1.1 聚类的一般过程"></a><strong>1.1 聚类的一般过程</strong></h4><ol>
<li>数据准备：特征标准化和降维</li>
<li>特征选择：从最初的特征中选择最有效的特征，并将其存储在向量中</li>
<li>特征提取：通过对选择的特征进行转换形成新的突出特征</li>
<li>聚类：基于某种距离函数进行相似度度量，获取簇</li>
<li>聚类结果评估：分析聚类结果，如<code>距离误差和(SSE)</code>等</li>
</ol>
<h4 id="1-2-数据对象间的相似度度量"><a href="#1-2-数据对象间的相似度度量" class="headerlink" title="1.2 数据对象间的相似度度量"></a><strong>1.2 数据对象间的相似度度量</strong></h4><p>对于数值型数据，可以使用下表中的相似度度量方法。</p>
<p><img src="https://pic3.zhimg.com/80/v2-921d5ff0b665e67d5df54047b9d6531a_720w.jpg" alt="img"></p>
<p><code>Minkowski</code>距离就是<img src="https://www.zhihu.com/equation?tex=+Lp+" alt="[公式]">范数（<img src="https://www.zhihu.com/equation?tex=p%E2%89%A51" alt="[公式]">)，而 <code>Manhattan</code> 距离、<code>Euclidean</code>距离、<code>Chebyshev</code>距离分别对应 <img src="https://www.zhihu.com/equation?tex=p=1,2,%E2%88%9E+" alt="[公式]">时的情形。</p>
<h4 id="1-3-cluster之间的相似度度量"><a href="#1-3-cluster之间的相似度度量" class="headerlink" title="1.3 cluster之间的相似度度量"></a><strong>1.3 cluster之间的相似度度量</strong></h4><p>除了需要衡量对象之间的距离之外，有些聚类算法（如层次聚类）还需要衡量<code>cluster</code>之间的距离 ，假设<img src="https://www.zhihu.com/equation?tex=+C_i+" alt="[公式]">和<img src="https://www.zhihu.com/equation?tex=+C_j" alt="[公式]"> 为两个 <code>cluster</code>，则前四种方法定义的 <img src="https://www.zhihu.com/equation?tex=C_i+" alt="[公式]">和 <img src="https://www.zhihu.com/equation?tex=C_j" alt="[公式]"> 之间的距离如下表所示。</p>
<p><img src="https://pic4.zhimg.com/80/v2-efc243a0fd595089412bd617eaa0d78b_720w.jpg" alt="img"></p>
<ul>
<li><code>Single-link</code>定义两个<code>cluster</code>之间的距离为两个<code>cluster</code>之间距离最近的两个点之间的距离，这种方法会在聚类的过程中产生<code>链式效应</code>，即有可能会出现非常大的<code>cluster</code></li>
<li><code>Complete-link</code>定义的是两个<code>cluster</code>之间的距离为两个``cluster<code>之间距离最远的两个点之间的距离，这种方法可以避免</code>链式效应`,对异常样本点（不符合数据集的整体分布的噪声点）却非常敏感，容易产生不合理的聚类</li>
<li><code>UPGMA</code>正好是<code>Single-link</code>和<code>Complete-link</code>方法的折中，他定义两个<code>cluster</code>之间的距离为两个<code>cluster</code>之间所有点距离的平均值</li>
<li>最后一种<code>WPGMA</code>方法计算的是两个 <code>cluster</code> 之间两个对象之间的距离的加权平均值，加权的目的是为了使两个 <code>cluster</code> 对距离的计算的影响在同一层次上，而不受 <code>cluster</code> 大小的影响，具体公式和采用的权重方案有关。</li>
</ul>
<h3 id="层次聚类-1"><a href="#层次聚类-1" class="headerlink" title="层次聚类"></a>层次聚类</h3><p>前面介绍的几种算法确实可以在较小的复杂度内获取较好的结果，但是这几种算法却存在一个<code>链式效应</code>的现象，比如：A与B相似，B与C相似，那么在聚类的时候便会将A、B、C聚合到一起，但是如果A与C不相似，就会造成聚类误差，严重的时候这个误差可以一直传递下去。为了降低<code>链式效应</code>，这时候层次聚类就该发挥作用了。</p>
<p><img src="https://pic3.zhimg.com/80/v2-0141f21130b60f7ac23fa05d7e417cee_720w.jpg" alt="img"></p>
<p><strong>层次聚类算法 (hierarchical clustering)</strong> 将数据集划分为一层一层的 <code>clusters</code>，后面一层生成的 <code>clusters</code> 基于前面一层的结果。层次聚类算法一般分为两类：</p>
<ul>
<li><strong>Agglomerative 层次聚类</strong>：又称自底向上（bottom-up）的层次聚类，每一个对象最开始都是一个 <code>cluster</code>，每次按一定的准则将最相近的两个 <code>cluster</code> 合并生成一个新的 <code>cluster</code>，如此往复，直至最终所有的对象都属于一个 <code>cluster</code>。这里主要关注此类算法。</li>
<li><strong>Divisive 层次聚类</strong>： 又称自顶向下（top-down）的层次聚类，最开始所有的对象均属于一个 <code>cluster</code>，每次按一定的准则将某个 <code>cluster</code> 划分为多个 <code>cluster</code>，如此往复，直至每个对象均是一个 <code>cluster</code>。</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-be2a7cf798fdc983e6521a68b1eb952d_720w.jpg" alt="img"></p>
<p>另外，需指出的是，层次聚类算法是一种贪心算法（greedy algorithm），因其每一次合并或划分都是基于某种局部最优的选择。</p>
<h2 id="层次聚类代码"><a href="#层次聚类代码" class="headerlink" title="层次聚类代码"></a>层次聚类代码</h2><p>（<a target="_blank" rel="noopener" href="https://blog.csdn.net/elaine_bao/article/details/50242867%EF%BC%89">https://blog.csdn.net/elaine_bao/article/details/50242867）</a></p>
<p>scipy cluster库简介<br>scipy.cluster是scipy下的一个做聚类的package, 共包含了两类聚类方法:</p>
<ol>
<li>矢量量化(scipy.cluster.vq):支持vector quantization 和 k-means 聚类方法</li>
<li>层次聚类(scipy.cluster.hierarchy):支持hierarchical clustering 和 agglomerative clustering(凝聚聚类)</li>
</ol>
<h1 id="轮廓系数分析"><a href="#轮廓系数分析" class="headerlink" title="轮廓系数分析"></a><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BD%AE%E5%BB%93%E7%B3%BB%E6%95%B0&spm=1001.2101.3001.7020">轮廓系数</a>分析</h1><ul>
<li>对于第i i<em>i</em>个对象，计算它到所属簇中所有其他元素的平均距离，记作a i a_i<em>a**i</em>(体现凝聚度)</li>
<li>对于第 i i<em>i</em> 个对象和不包含该对象的任意簇，计算该对象到给定簇中所有对象的平均距离，记 b i b_i<em>b**i</em> （体现分离度）</li>
<li>第 i 个对象的轮廓系数为 s i = ( b i − a i ) m a x ( a i , b i ) s_i = \frac{(bi-ai)}{max(ai, bi)}<em>s**i</em>=<em>m<strong>a</strong>x</em>(<em>a**i</em>,<em>b**i</em>)(<em>b**i</em>−<em>a**i</em>)</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/03/31/python%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/03/31/python%E7%9A%84%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">python的使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-31 16:54:15" itemprop="dateCreated datePublished" datetime="2022-03-31T16:54:15+08:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-11 16:20:52" itemprop="dateModified" datetime="2022-10-11T16:20:52+08:00">2022-10-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="conda的常用命令"><a href="#conda的常用命令" class="headerlink" title="conda的常用命令"></a>conda的常用命令</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hejp_123/article/details/92151293">https://blog.csdn.net/hejp_123/article/details/92151293</a></p>
<h2 id="Resource-punkt-not-found"><a href="#Resource-punkt-not-found" class="headerlink" title="Resource punkt not found."></a>Resource punkt not found.</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24263553/article/details/105726751">https://blog.csdn.net/qq_24263553/article/details/105726751</a></p>
<h3 id="导入包的问题-sys-path"><a href="#导入包的问题-sys-path" class="headerlink" title="导入包的问题 sys.path"></a>导入包的问题 sys.path</h3><p>直接运行 和 模块运行 的区别<br>python xxx.py<br>python -m xxx.py<br>这是两种加载py文件的方式:<br>1叫做直接运行<br>2把模块当作脚本来启动(注意：但是__name__的值为’main’ )</p>
<p>直接启动是把xx.py文件，所在的目录放到了sys.path属性中。<br>模块启动是把你输入命令的目录（也就是当前路径），放到了sys.path属性中</p>
<p>作者：大富帅<br>链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/04701cb81e38">https://www.jianshu.com/p/04701cb81e38</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="requests-的session的使用-重定向问题"><a href="#requests-的session的使用-重定向问题" class="headerlink" title="requests 的session的使用 重定向问题"></a>requests 的session的使用 重定向问题</h3><p>会话也可用来为请求方法提供缺省数据。这是通过为会话对象的属性提供数据来实现的：</p>
<p>s = requests.Session()<br>s.auth = (‘user’, ‘pass’)<br>s.headers.update({‘x-test’: ‘true’})</p>
<h1 id="both-‘x-test’-and-‘x-test2’-are-sent"><a href="#both-‘x-test’-and-‘x-test2’-are-sent" class="headerlink" title="both ‘x-test’ and ‘x-test2’ are sent"></a>both ‘x-test’ and ‘x-test2’ are sent</h1><p>s.get(‘<a target="_blank" rel="noopener" href="http://httpbin.org/headers&#39;">http://httpbin.org/headers&#39;</a>, headers={‘x-test2’: ‘true’})<br>任何你传递给请求方法的字典都会与已设置会话层数据合并。方法层的参数覆盖会话的参数。</p>
<p>不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求(指两次session.get       )保持。下面的例子只会和第一个请求发送 ​cookie​ ，而非第二个：</p>
<p>s = requests.Session()</p>
<p>r = s.get(‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;">http://httpbin.org/cookies&#39;</a>, cookies={‘from-my’: ‘browser’})<br>print(r.text)</p>
<h1 id="‘-“cookies”-“from-my”-“browser”-’"><a href="#‘-“cookies”-“from-my”-“browser”-’" class="headerlink" title="‘{“cookies”: {“from-my”: “browser”}}’"></a>‘{“cookies”: {“from-my”: “browser”}}’</h1><p>r = s.get(‘<a target="_blank" rel="noopener" href="http://httpbin.org/cookies&#39;">http://httpbin.org/cookies&#39;</a>)<br>print(r.text)</p>
<h1 id="‘-“cookies”-’"><a href="#‘-“cookies”-’" class="headerlink" title="‘{“cookies”: {}}’"></a>‘{“cookies”: {}}’</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/03/23/JetsonTX2%E7%9A%84%E4%BA%8B%E6%83%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/03/23/JetsonTX2%E7%9A%84%E4%BA%8B%E6%83%85/" class="post-title-link" itemprop="url">JetsonTX2的事情</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 19:38:04" itemprop="dateCreated datePublished" datetime="2022-03-23T19:38:04+08:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-23 21:19:39" itemprop="dateModified" datetime="2023-02-23T21:19:39+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/TX2/" itemprop="url" rel="index"><span itemprop="name">TX2</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="APT换源"><a href="#APT换源" class="headerlink" title="APT换源"></a>APT换源</h2><p>注意使用<code>hostnamectl</code>查看系统架构是arm64</p>
<p>使用阿里云\清华大学\北京外国语大学的<strong>ubuntu ports</strong>开源软件镜像站都存在问题</p>
<p>使用中科大镜像站即可</p>
<h2 id="控制风扇转速"><a href="#控制风扇转速" class="headerlink" title="控制风扇转速"></a>控制风扇转速</h2><p>在任意路径下，输入: <code>sudo nvpmodel --query</code><br>显示工作在m2模式下，即15w模式，此时风扇默认不开，此时输入：<br><code>sudo jetson_clocks</code><br>会听到风扇转起来了，声音很大，再次查看当前Xavier的工作模式：<br><code>sudo nvpmodel --query</code><br>输出m0模式，也就是全速模式。</p>
<p><code>sudo gedit /sys/devices/pwm-fan/target_pwm</code><br>修改数字为0-255之间的值即可改变转速</p>
<h2 id="温度检测"><a href="#温度检测" class="headerlink" title="温度检测"></a>温度检测</h2><p>硬件温度检测工具<strong>sensors</strong>。<br><code>sudo apt install lm-sensors</code><br>安装成功以后，输入：<br><code>sensors</code><br>系统会显示当前温度，一般不开风扇的话系统温度能达到40度左右。</p>
<p>持续显示<br>tegrastats</p>
<p>watch<br>命令功能：<br>可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令</p>
<p>命令参数：<br>参数详解<br>-n或–intervalwatch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。<br>-d或–differences用 -d 或 –differences 选项,watch 会高亮显示变化的区域。而</p>
<h2 id="查看L4T版本"><a href="#查看L4T版本" class="headerlink" title="查看L4T版本"></a>查看L4T版本</h2><p><code>head -n 1 /etc/nv_tegra_release</code></p>
<h2 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h2><h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43715489/article/details/107980338">https://blog.csdn.net/qq_43715489/article/details/107980338</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/greepex/article/details/103876921">https://blog.csdn.net/greepex/article/details/103876921</a></p>
<p>先下载文件系统</p>
<p>进入Linux_for_Tegra目录，执行一次（以后要用就不执行了）<code>sudo ./apply_binaries.sh</code></p>
<p>查看是否处于强制恢复模式lsusb</p>
<p>看看有没有0955：7c18的Nvidia crop</p>
<p>烧写到emmc的方式<code>sudo ./flash.sh jetson-tx2 mmcblk0p1</code></p>
<h2 id="TX2的不同模式及切换"><a href="#TX2的不同模式及切换" class="headerlink" title="TX2的不同模式及切换"></a>TX2的不同模式及切换</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xxradon/article/details/87932441">https://blog.csdn.net/xxradon/article/details/87932441</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luotingliang/p/7248672.html">https://www.cnblogs.com/luotingliang/p/7248672.html</a></p>
<h2 id="TX2控制界面-desktop-sharing打不开"><a href="#TX2控制界面-desktop-sharing打不开" class="headerlink" title="TX2控制界面 desktop sharing打不开"></a>TX2控制界面 desktop sharing打不开</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38129331/article/details/107859137">https://blog.csdn.net/qq_38129331/article/details/107859137</a></p>
<h2 id="TX2远程桌面"><a href="#TX2远程桌面" class="headerlink" title="TX2远程桌面"></a>TX2远程桌面</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jiangchao3392/article/details/73252291">https://blog.csdn.net/jiangchao3392/article/details/73252291</a></p>
<h2 id="将固态作为启动盘"><a href="#将固态作为启动盘" class="headerlink" title="将固态作为启动盘"></a>将固态作为启动盘</h2><ol>
<li><p>准备 TX2 系统 准备一个有系统 TX2 设备，该系统版本要和 host pc 机上烧录环境的系统版本要一致。查看 TX2 系统 版 本 $ head –n 1 /etc/nv_tegra_release 如 果 host pc 上 未 搭 建 过 烧 录 环 境 ， 参 考 <a target="_blank" rel="noopener" href="https://www.realtimes.cn/cn/help.html">https://www.realtimes.cn/cn/help.html</a> 帮助文档-《TX2 系统烧录说明》搭建烧录环境。 该文档以使用 9002u 载板为例，50GB mSATA SSD。</p>
</li>
<li><p>检查 SSD 设备名称 把 mSATASSD 插到设备上的 mSATA 接口上。使用 sudo fdisk -l 查看 ssd 设备名称。比如：sda，本文 档中之后 ssd 设备名都以 sda 为例。</p>
</li>
<li><p>创建一个新的 GPT $ sudo parted /dev/sda mklabel gpt</p>
</li>
<li><p>添加分区 $ sudo parted /dev/sda mkpart primary 0GB  Size 是分区的大小，最小 8GB，建议 32GB 以上 例如：准备分区大小为 40GB $ sudo parted /dev/sda mkpart primary 0GB 40GB 添加完分区后，使用 sudo fdisk -l 可以看到 sda 新增一个分区，比如 sda1。</p>
</li>
<li><p>格式化分区 $ sudo mkfs.ext4 /dev/sda1 把分区格式化为 ext4 格式</p>
</li>
<li><p>查看分区的 UUID $sudo blkid /dev/sda1 例如：/dev/sda1: UUID=”7b568e36-831e-4975-babe-6d2eaf585aa4” TYPE=”ext4” PARTLABEL=”primary”  PARTUUID=”4f71e1b5-70b5-4582-8a1e-51ef993b3bd0”</p>
</li>
<li><p>保存 PARTUUID 的值 把 PARTUUID 的值保存到临时存储设备上，u 盘或者其他方式保存，以备后续使用。</p>
</li>
<li><p>拷贝根文件系统到 sdd 分区上 $ sudo dd if=/dev/mmcblk0p1 of=/dev/sda1</p>
</li>
<li><p>调整分区大小 1)卸载磁盘：umount /media/xxx(路径) 2)$ e2fsck -f /dev/sda1 3)$ sudo resize2fs /dev/sda1</p>
</li>
<li><p>向 l4t-rootfs-uuid.txt 写入 PARTUUID 的值 在 host pc 机上切换到烧录环境 Linux_for_Tegra 目录 $ echo ‘4f71e1b5-70b5-4582-8a1e-51ef993b3bd0’ &gt; /bootloader/l4t-rootfs-uuid.txt</p>
</li>
<li><p>向 TX2 设备烧写一个从外部设备启动的系统 在 host pc 机 以使用 RTSO-9002u 载板为例 使 TX2 设备进入 recovery 模式 $sudo ./flash.sh realtimes/rtso-9002u external</p>
</li>
<li><p>查看是否从 SSD 中启动系统 在 TX2 系统启动后 $ df -h  显示 sda1 已经成为根目录以及文件系统大</p>
</li>
</ol>
<h3 id="parted提示更新-etc-fstab-文件内容"><a href="#parted提示更新-etc-fstab-文件内容" class="headerlink" title="parted提示更新/etc/fstab 文件内容"></a>parted提示更新/etc/fstab 文件内容</h3><p>添加固态的挂载到/media/nvidia(新建即可)<br>=i</p>
<h3 id="dd命令速度太慢"><a href="#dd命令速度太慢" class="headerlink" title="dd命令速度太慢"></a>dd命令速度太慢</h3><p>以后应该使用 <code>pv</code> 来获取运行进度条。</p>
<pre><code>sudo apt-get install pv
</code></pre>
<p>安装 <code>pv</code> 后，假设您要将 20GB 驱动器 <code>/dev/foo</code> 克隆到另一个驱动器(20GB 或更大！)， <code>/dev/baz</code> ：</p>
<pre><code>sudo dd if=/dev/foo bs=4M | pv -s 20G | sudo dd of=/dev/baz bs=4M
</code></pre>
<p>需要注意的重要部分：<code>bs=4M</code> 参数将 dd 操作的块大小设置为 4MB，这大大提高了整个过程的速度。而 <code>-s 20G</code> 参数告诉 <code>pv</code> 这个操作预计有多大，所以它可以给你一个 ETA 以及当前速度。</p>
<p>我非常喜欢 <code>pv</code>，它应该是非法的。</p>
<p>请注意，虽然这样做从左到右的顺序是直观、美观和整洁的，但如果您谈论的是真正快速的数据流，则传入和传出 STDOUT 的管道可能会导致性能损失。如果您正在考虑移动数百 MB/秒，以下语法会更快：</p>
<pre><code>pv -s 20G &lt; /dev/foo &gt; /dev/baz
</code></pre>
<p><code>-s 20G</code> 是可选的，如果您确实知道流有多大(或大约有多大)，它允许 <code>pv</code> 为您提供完成时间的估计。如果没有这个，<code>pv</code> 将尝试找出数据集有多大(例如，它知道文件有多大)，但如果不能(例如，使用块设备，而不是文件)，它只会告诉你无需猜测事情将需要多长时间的传输速率。</p>
<h2 id="TX2安装ROS"><a href="#TX2安装ROS" class="headerlink" title="TX2安装ROS"></a>TX2安装ROS</h2><p><a target="_blank" rel="noopener" href="https://www.guyuehome.com/10082">https://www.guyuehome.com/10082</a></p>
<h2 id="安装ros-wrapper"><a href="#安装ros-wrapper" class="headerlink" title="安装ros wrapper"></a>安装ros wrapper</h2><p><a target="_blank" rel="noopener" href="https://github.com/IntelRealSense/realsense-ros%E5%AE%98%E6%96%B9git%E4%BB%93%E5%BA%93">https://github.com/IntelRealSense/realsense-ros官方git仓库</a></p>
<p><a target="_blank" rel="noopener" href="https://www.freesion.com/article/7219741032/">https://www.freesion.com/article/7219741032/</a> 不行</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41839222/article/details/86503113">https://blog.csdn.net/qq_41839222/article/details/86503113</a> 详细 和其他vins-momo之类的</p>
<h3 id="在根目录创建工作空间后catkin-init-workspace找不到命令"><a href="#在根目录创建工作空间后catkin-init-workspace找不到命令" class="headerlink" title="在根目录创建工作空间后catkin_init_workspace找不到命令"></a>在根目录创建工作空间后catkin_init_workspace找不到命令</h3><p>sudo apt-get install python-catkin-tools</p>
<p>sudo su<br>echo “source /opt/ros/kinetic/setup.bash” &gt;&gt;/etc/profile</p>
<p>最开始我们都在.bashrc中配置过环境变量，这里也要改。/etc/profile是配置所有用户的环境变量</p>
<h3 id="Project-‘cv-bridge’-specifies-‘-usr-include-opencv’-as-an-include-dir-which-is-not-found"><a href="#Project-‘cv-bridge’-specifies-‘-usr-include-opencv’-as-an-include-dir-which-is-not-found" class="headerlink" title="Project ‘cv_bridge’ specifies ‘/usr/include/opencv’ as an include dir, which is not found"></a>Project ‘cv_bridge’ specifies ‘/usr/include/<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=opencv&spm=1001.2101.3001.7020">opencv</a>’ as an include dir, which is not found</h3><p>将cmake文件100行左右的两个opencv改为opencv4</p>
<p>这不是因为我们编写的程序有误，而是NVIDIA的32.3.1image自带的是opencv4版本，把opencv命名成了opencv4</p>
<p>修改方法：只需修改上述路径中的cv_bridgeconfig.cmke文件，将100行附近的两个opencv改成opencv4即可（注意，只需要改动单独一个的opencv,前面有连字符的opencv不需要改动）</p>
<p>注意：如果jetson nano的版本自带的opencv是3版本，可能不会出现此问题</p>
<h2 id="Frames-didn’t-arrived-within-5-seconds"><a href="#Frames-didn’t-arrived-within-5-seconds" class="headerlink" title="Frames didn’t arrived within 5 seconds"></a>Frames didn’t arrived within 5 seconds</h2><h3 id="或者SDK中点击启动后会报错：device-or-resource-is-not-available之类的"><a href="#或者SDK中点击启动后会报错：device-or-resource-is-not-available之类的" class="headerlink" title="或者SDK中点击启动后会报错：device or resource is not available之类的"></a>或者SDK中点击启动后会报错：device or resource is not available之类的</h3><p>这其实是因为相机中的固件(firmware)需要更新版本。<br>连上相机，按照以下链接更新固件部分操作即可：<br><a target="_blank" rel="noopener" href="http://www.pianshen.com/article/6519141340/">http://www.pianshen.com/article/6519141340/</a></p>
<h3 id="报错cmake的问题或者和ddynamic-reconfigure有关"><a href="#报错cmake的问题或者和ddynamic-reconfigure有关" class="headerlink" title="报错cmake的问题或者和ddynamic_reconfigure有关"></a>报错cmake的问题或者和ddynamic_reconfigure有关</h3><p>是缺少安装ddynamic_reconfigure的包,所以要再安装一下,打开链接<a target="_blank" rel="noopener" href="https://github.com/pal-robotics/ddynamic_reconfigure/tree/kinetic-devel">https://github.com/pal-robotics/ddynamic_reconfigure/tree/kinetic-devel</a>,直接将这个仓库下载到工作空间src中,也就是用git clone命令即可</p>
<h3 id="ros常用操作"><a href="#ros常用操作" class="headerlink" title="ros常用操作"></a>ros常用操作</h3><ol>
<li>创建工作空间</li>
</ol>
<pre><code>  mkdir -p  /program1/src
  cd /program1/src
  catkin_init_workspace
  cd  /program/
  catkin_make
  source devel/setup.bash
  echo &quot;source /program1/devel/setup.bash&quot;&gt;&gt;~/.bashrc
</code></pre>
<ol start="2">
<li>创建功能包<ul>
<li><code>cd /program1/src</code></li>
<li><code>catkin_create_pkg package1 std_msgs rospy roscpp</code></li>
</ul>
</li>
</ol>
<h2 id="安装opencv"><a href="#安装opencv" class="headerlink" title="安装opencv"></a>安装opencv</h2><p>一行命令</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45885232/article/details/108994685">https://blog.csdn.net/weixin_45885232/article/details/108994685</a></p>
<p>sudo apt install python3-opencv</p>
<h2 id="固态硬盘接口种类"><a href="#固态硬盘接口种类" class="headerlink" title="固态硬盘接口种类"></a>固态硬盘接口种类</h2><ol>
<li>SATA接口</li>
<li>mSATA接口</li>
<li>M.2接口<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/shuai0845/article/details/98330290">https://blog.csdn.net/shuai0845/article/details/98330290</a></li>
</ol>
<h2 id="ROS主从机"><a href="#ROS主从机" class="headerlink" title="ROS主从机"></a>ROS主从机</h2><ul>
<li>使用localhost要ping的通</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://pleasecallmeboss.github.io/blog/2022/03/22/Ubuntu%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.gif">
      <meta itemprop="name" content="咦蜘蛛">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="咦蜘蛛的个人博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/blog/2022/03/22/Ubuntu%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">Ubuntu操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-22 16:23:31" itemprop="dateCreated datePublished" datetime="2022-03-22T16:23:31+08:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-23 21:30:56" itemprop="dateModified" datetime="2023-02-23T21:30:56+08:00">2023-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/%E6%95%99%E7%A8%8B/" itemprop="url" rel="index"><span itemprop="name">教程</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="apt-get和aptitude的区别"><a href="#apt-get和aptitude的区别" class="headerlink" title="apt-get和aptitude的区别"></a>apt-get和aptitude的区别</h2><ol>
<li><p>apt-get<br>apt-get update——在修改/etc/apt/sources.list或者/etc/apt/preferences之後运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的。<br>apt-get install packagename——安装一个新软件包（参见下文的aptitude ）<br>apt-get remove packagename——卸载一个已安装的软件包（保留配置文件）<br>apt-get –purge remove packagename——卸载一个已安装的软件包（删除配置文件）<br>dpkg –force-all –purge packagename 有些软件很难卸载，而且还阻止了别的软件的应用 ，就可以用这个，不过有点冒险。<br>apt-get autoclean apt会把已装或已卸的软件都备份在硬盘上，所以如果需要空间 的话，可以让这个命令来删除你已经删掉的软件<br>apt-get clean 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的。<br>apt-get upgrade——更新所有已安装的软件包<br>apt-get dist-upgrade——将系统升级到新版本<br>apt-cache search string——在软件包列表中搜索字符串<br>dpkg -l package-name-pattern——列出所有与模式相匹配的软件包。如果您不知道软件包的全名，您可以使用“<em>package-name-pattern</em>”。<br>aptitude——详细查看已安装或可用的软件包。与apt-get类似，aptitude可以通过命令行方式调用，但仅限于某些命令——最常见的有安装和卸载命令。由于aptitude比apt-get了解更多信息，可以说它更适合用来进行安装载。<br>apt-cache showpkg pkgs——显示软件包信息。<br>apt-cache dumpavail——打印可用软件包列表。<br>apt-cache show pkgs——显示软件包记录，类似于dpkg –print-avail。<br>apt-cache pkgnames——打印软件包列表中所有软件包的名称。<br>dpkg -S file——这个文件属于哪个已安装软件包。<br>dpkg -L package——列出软件包中的所有文件。<br>apt-file search filename——查找包含特定文件的软件包（不一定是已安装的），这些文件的文件名中含有指定的字符串。apt-file是一个独立的软件包。您必须 先使用apt-get install来安装它，然後运行apt-fileupdate。如果apt-file search filename输出的内容太多，您可以尝试使用apt-file search filename | grep -w filename（只显示指定字符串作为完整的单词出现在其中的那些文件名）或者类似方法，例如apt-file search filename | grep /qfdgk/（只显示位于诸如/qfdgk或/usr/qfdgk这些文件夹中的文件，如果您要查找的是某个特定的执行文件的话，这样做是有帮助的）。</p>
</li>
<li><p>aptitude<br>aptitude 与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude 在处理依赖问题上更佳一些。举例来说，aptitude 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。以下是笔者总结的一些常用 aptitude 命令，仅供参考。<br>命令 作用<br>aptitude update 更新可用的包列表<br>aptitude upgrade 升级可用的包<br>aptitude dist-upgrade 将系统升级到新的发行版<br>aptitude install pkgname 安装包<br>aptitude remove pkgname 删除包<br>aptitude purge pkgname 删除包及其配置文件<br>aptitude search string 搜索包<br>aptitude show pkgname 显示包的详细信息<br>aptitude clean 删除下载的包文件<br>aptitude autoclean 仅删除过期的包文件</p>
</li>
</ol>
<p>当然，你也可以在文本界面模式中使用 aptitude。</p>
<h2 id="挂载命令"><a href="#挂载命令" class="headerlink" title="挂载命令"></a>挂载命令</h2><p>mount [-t vfstype] [-o options] device dir<br>umount /mnt/cdrom</p>
<p>systemd:</p>
<p>hostnamectl:查看主机名，操作系统，内核，架构<br>systemd启动的第一个进程<br>Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。</p>
<p>systemctl enable命令用于在上面两个目录之间，建立符号链接关系。</p>
<pre><code>$ sudo systemctl enable clamd@scan.service
# 等同于
$ sudo ln -s &#39;/usr/lib/systemd/system/clamd@scan.service&#39; &#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service&#39;
</code></pre>
<p>如果配置文件里面设置了开机启动，systemctl enable命令相当于激活开机启动。</p>
<p>与之对应的，systemctl disable命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</p>
<pre><code>sudo systemctl disable clamd@scan.service
</code></pre>
<p>配置文件的后缀名，就是该 Unit 的种类，比如sshd.socket。如果省略，Systemd 默认后缀名为.service，所以sshd会被理解成sshd.service。</p>
<p>学习systemd：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html">http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1516125">https://cloud.tencent.com/developer/article/1516125</a></p>
<p>新建开机服务：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/396272999">https://zhuanlan.zhihu.com/p/396272999</a></p>
<h2 id="定期自动运行程序"><a href="#定期自动运行程序" class="headerlink" title="定期自动运行程序"></a>定期自动运行程序</h2><p>Linux有一个称为crond的守护程序，主要功能是周期性地检查 /var/spool/cron目录下的一组命令文件的内容，并在设定的时间执行这些文件中的命令。用户可以通过crontab 命令来建立、修改、删除这些命令文件。</p>
<p>例如，建立文件crondFile，内容为“00 9 23 Jan ＊ HappyBirthday”，运行“crontabcronFile”命令后，每当元月23日上午9:00系统自动执行“HappyBirthday”的程序（“＊”表示不管当天是星期几）。</p>
<p>设置定时任务：</p>
<p>sudo crontab -e</p>
<p>填入以下内容</p>
<p>//每月1号和15号的4点30分开始更新<br>30 4 1,15 ** sh [脚本目录]/[脚本名称]</p>
<p>重启crontab，使配置生效</p>
<p>sudo systemctl restart cron.service</p>
<h2 id="github的push操作认证"><a href="#github的push操作认证" class="headerlink" title="github的push操作认证"></a>github的push操作认证</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sober-orange/p/git-token-push.html">https://www.cnblogs.com/sober-orange/p/git-token-push.html</a></p>
<h2 id="hexo环境上传到github"><a href="#hexo环境上传到github" class="headerlink" title="hexo环境上传到github"></a>hexo环境上传到github</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/eidolonw/p/13066869.html">https://www.cnblogs.com/eidolonw/p/13066869.html</a></p>
<p>(参考)<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39431829/article/details/88959366">https://blog.csdn.net/qq_39431829/article/details/88959366</a></p>
<h2 id="双系统引导过程"><a href="#双系统引导过程" class="headerlink" title="双系统引导过程"></a>双系统引导过程</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liao20081228/article/details/82591728">https://blog.csdn.net/liao20081228/article/details/82591728</a></p>
<h2 id="git-ssh配置"><a href="#git-ssh配置" class="headerlink" title="git ssh配置"></a>git ssh配置</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lqlqlq007/article/details/78983879">https://blog.csdn.net/lqlqlq007/article/details/78983879</a></p>
<h3 id="设置root用户密码"><a href="#设置root用户密码" class="headerlink" title="设置root用户密码"></a>设置root用户密码</h3><p><code>sudo passwd</code></p>
<p>输入的密码为root用户的新密码</p>
<h2 id="zsh的安装"><a href="#zsh的安装" class="headerlink" title="zsh的安装"></a>zsh的安装</h2><p>查看系统当前使用的shell</p>
<blockquote>
<p>echo $SHELL</p>
</blockquote>
<p>查看系统安装了哪些shell</p>
<blockquote>
<p>cat /etc/shells</p>
</blockquote>
<p>查看zsh的安装位置</p>
<blockquote>
<p>which zsh</p>
</blockquote>
<p>把默认的Shell改成zsh（为当前用户）</p>
<pre><code class="bash">chsh -s /bin/zsh
</code></pre>
<p>安装主题 on-my-zsh</p>
<p>sh -c “$(curl -fsSL <a target="_blank" rel="noopener" href="https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh">https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh</a>)”</p>
<h3 id="安装incr自动补全插件"><a href="#安装incr自动补全插件" class="headerlink" title="安装incr自动补全插件"></a>安装incr自动补全插件</h3><p>下载插件</p>
<blockquote>
<p>wget <a target="_blank" rel="noopener" href="http://mimosa-pudica.net/src/incr-0.2.zsh">http://mimosa-pudica.net/src/incr-0.2.zsh</a></p>
</blockquote>
<p>移动插件到oh-my-zsh目录的插件库下</p>
<blockquote>
<p>sudo mkdir ~/.oh-my-zsh/plugins/incr/</p>
<p>sudo mv incr-0.2.zsh ~/.oh-my-zsh/plugins/incr/incr-0.2.zsh</p>
</blockquote>
<p>进入vim编辑</p>
<blockquote>
<p>sudo vim ~/.zshrc</p>
</blockquote>
<p>在vim界面按i进入输入模式在末尾加上如下代码</p>
<blockquote>
<p>source ~/.oh-my-zsh/plugins/incr/incr*.zsh</p>
</blockquote>
<p>按esc进入一般模式输入以下内容后回车以保存退出</p>
<blockquote>
<p>：qw</p>
</blockquote>
<p>更新配置</p>
<blockquote>
<p>source ~/.zshrc</p>
</blockquote>
<h3 id="更换agnoster主题"><a href="#更换agnoster主题" class="headerlink" title="更换agnoster主题"></a>更换agnoster主题</h3><p>安装字体</p>
<blockquote>
<p>sudo apt install fonts-powerline</p>
</blockquote>
<p>进入vim编辑</p>
<blockquote>
<p>sudo vim ~/.zshrc</p>
</blockquote>
<p>在vim界面按i进入输入模式找到ZSH_THEME=”robbyrussell”将其中robbyrussell修改为agnoster</p>
<p>按esc进入一般模式输入：qw回车保存退出</p>
<p>更新配置</p>
<blockquote>
<p>source ~/.zshrc</p>
</blockquote>
<h3 id="其他问题-git卡顿"><a href="#其他问题-git卡顿" class="headerlink" title="其他问题 git卡顿"></a>其他问题 git卡顿</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/anlz729/article/details/108768918">https://blog.csdn.net/anlz729/article/details/108768918</a></p>
<h2 id="验证代理是否正常"><a href="#验证代理是否正常" class="headerlink" title="验证代理是否正常"></a>验证代理是否正常</h2><pre><code>测试http
</code></pre>
<p>curl ‘ip111.cn’</p>
<p>curl -s <a target="_blank" rel="noopener" href="http://myip.ipip.net/">http://myip.ipip.net</a></p>
<ol start="2">
<li>测试https</li>
</ol>
<p>curl ‘<a target="_blank" rel="noopener" href="https://api.myip.la/cn?json">https://api.myip.la/cn?json</a>‘</p>
<p>curl ‘<a target="_blank" rel="noopener" href="https://ipinfo.io/&#39;">https://ipinfo.io/&#39;</a></p>
<h2 id="netstat的使用"><a href="#netstat的使用" class="headerlink" title="netstat的使用"></a>netstat的使用</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html">https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html</a></p>
<h2 id="远程桌面连接"><a href="#远程桌面连接" class="headerlink" title="远程桌面连接"></a>远程桌面连接</h2><p>vnc方式：<a target="_blank" rel="noopener" href="https://blog.csdn.net/langyou0/article/details/107959002">https://blog.csdn.net/langyou0/article/details/107959002</a></p>
<h2 id="df命令"><a href="#df命令" class="headerlink" title="df命令"></a>df命令</h2><p>df</p>
<p>df -a 显示全部文件系统</p>
<p>df -h 单位以人类易于阅读的方式</p>
<p>df -T 显示文件系统类型</p>
<h2 id="查看cpu"><a href="#查看cpu" class="headerlink" title="查看cpu"></a>查看cpu</h2><p>lscpu</p>
<h2 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h2><p>free</p>
<h2 id="安装KDE桌面环境"><a href="#安装KDE桌面环境" class="headerlink" title="安装KDE桌面环境"></a>安装KDE桌面环境</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39670511/article/details/110594726">https://blog.csdn.net/weixin_39670511/article/details/110594726</a></p>
<p><a target="_blank" rel="noopener" href="https://ubuntuqa.com/article/9604.html">https://ubuntuqa.com/article/9604.html</a></p>
<h2 id="命令行配置无线有线网络"><a href="#命令行配置无线有线网络" class="headerlink" title="命令行配置无线有线网络"></a>命令行配置无线有线网络</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/luotingliang/p/7248672.html">https://www.cnblogs.com/luotingliang/p/7248672.html</a></p>
<h2 id="PS命令"><a href="#PS命令" class="headerlink" title="PS命令"></a>PS命令</h2><p>tty[1-6]就是你用ctr+alt+f[1-6]所看到的那个终端; 即虚拟控制台。其他的是外部终端和网络终端。</p>
<p>pts/*为伪(虚拟)终端，当前打开了两个终端窗口，所以就有pts/0和pts/1</p>
<p>ps -a 显示现行终端机下的所有进程，包括其他用户的进程</p>
<p>-A 所有的进程均显示出来，与 -e 具有同样的效用</p>
<p>-l 详细的</p>
<p>-u 以</p>
<h2 id="静态IP设置"><a href="#静态IP设置" class="headerlink" title="静态IP设置"></a>静态IP设置</h2><p><a target="_blank" rel="noopener" href="https://www.itbulu.com/ubuntu-setting-ips.html">https://www.itbulu.com/ubuntu-setting-ips.html</a></p>
<h2 id="source-not-found"><a href="#source-not-found" class="headerlink" title="source not found"></a>source not found</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/erlou96/p/13398387.html">https://www.cnblogs.com/erlou96/p/13398387.html</a></p>
<h2 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h2><p>1.vim ~/.bashrc</p>
<p>2.添加 alias name=’command’即可。重启后即可生效,或执行source .bashrc也可立即生效</p>
<h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhang-jun-jie/p/9266858.html">https://www.cnblogs.com/zhang-jun-jie/p/9266858.html</a></p>
<h2 id="局域网主机之间测速"><a href="#局域网主机之间测速" class="headerlink" title="局域网主机之间测速"></a>局域网主机之间测速</h2><p><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/25648fc16e8c9d9191fd00a0.html">https://jingyan.baidu.com/article/25648fc16e8c9d9191fd00a0.html</a></p>
<h2 id="实时测速"><a href="#实时测速" class="headerlink" title="实时测速"></a>实时测速</h2><p>添加在上方图标</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/jsdy/p/11461277.html">https://www.cnblogs.com/jsdy/p/11461277.html</a></p>
<p>命令行 slurm</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhengfushijie/article/details/49050607?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=1">https://blog.csdn.net/zhengfushijie/article/details/49050607?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_paycolumn_v3&amp;utm_relevant_index=1</a></p>
<h2 id="开机自动挂载u盘"><a href="#开机自动挂载u盘" class="headerlink" title="开机自动挂载u盘"></a>开机自动挂载u盘</h2><p>[UUID=************] [挂载磁盘分区] [挂载磁盘格式] 0 2</p>
<p>添加的行是13行，UUID和挂载目录/home/sqp/Data以及硬盘格式ext4</p>
<p>第一数字0，0是开机不检查磁盘，1是开机检查磁盘</p>
<p>第二个数2，0表示交换分区，1表示启动分区，2表示普通分区</p>
<h2 id="script编写"><a href="#script编写" class="headerlink" title="script编写"></a>script编写</h2><h3 id="echo-选项-参数-选项"><a href="#echo-选项-参数-选项" class="headerlink" title="echo(选项)(参数)选项"></a>echo(选项)(参数)选项</h3><p>-e：激活转义字符。使用-e选项时，若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出：</p>
<p>•\a 发出警告声；</p>
<h3 id="指令运作的顺序"><a href="#指令运作的顺序" class="headerlink" title="指令运作的顺序"></a>指令运作的顺序</h3><ol>
<li>以相对/绝对路径执行指令，例如『 /bin/ls 』或『 ./ls 』；</li>
<li>由 alias 找到该指令来执行；</li>
<li>由 bash 内建的 (builtin) 指令来执行；</li>
<li>透过 $PATH 这个变量的顺序搜寻到的第一个指令来执行。</li>
</ol>
<h3 id="快速删除和光标快速移动"><a href="#快速删除和光标快速移动" class="headerlink" title="快速删除和光标快速移动"></a>快速删除和光标快速移动</h3><p>[ctrl]+u/[ctrl]+k 分别是从光标处向前删除指令串 ([ctrl]+u) 及向后删除指令串 ([ctrl]+k)。 [ctrl]+a/[ctrl]+e 分别是让光标移动到整个指令串的最前面 ([ctrl]+a) 或最后面 ([ctrl]+e)</p>
<h3 id="单引号和双引号的区别"><a href="#单引号和双引号的区别" class="headerlink" title="单引号和双引号的区别"></a>单引号和双引号的区别</h3><p>变量内容若有空格符可使用双引号『”』或单引号『’』将变量内容结合起来，</p>
<p>但 o双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：</p>
<p>『var=”lang is $LANG”』则『echo $var』可得『lang is zh_TW.UTF-8』</p>
<p>单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：</p>
<p>『var=’lang is $LANG’』则『echo $var』可得『lang is $LANG』</p>
<h3 id="追加变量内容"><a href="#追加变量内容" class="headerlink" title="追加变量内容"></a>追加变量内容</h3><p>『PATH=”$PATH”:/home/bin』或『PATH=${PATH}:/home/bin』</p>
<h3 id="使用其他指令提供的信息"><a href="#使用其他指令提供的信息" class="headerlink" title="使用其他指令提供的信息"></a>使用其他指令提供的信息</h3><p>『version=$(uname -r)』再『echo $version』可得『3.10.0-229.el7.x86_64』</p>
<h2 id="仓库详解"><a href="#仓库详解" class="headerlink" title="仓库详解"></a>仓库详解</h2><h3 id="版本号-代号-时间"><a href="#版本号-代号-时间" class="headerlink" title="版本号 代号 时间"></a>版本号 代号 时间</h3><blockquote>
<p>Ubuntu可谓是Linux世界中的黑马，其第一个正式版本于2004年10月正式推出。需要详细解释的是Ubuntu版本编号的定义，其编号以“年份的最后一位.发布月份”的格式命名，因此Ubuntu的第一个版本就称为4.10(2004.10)。除了代号之外，每个Ubuntu版本在开发之初还有一个开发代号。Ubuntu开发代号比较有意思，格式为“形容词+动物”，且形容词和动物名称的第一个字母要一致，如Ubuntu16.04的开发代号是Xenial Xerus，译为“好客的非洲地松鼠”。 [6]  从Ubuntu 6.06开始，两个词的首字母按照英文字母表的排列顺序取用。</p>
</blockquote>
<table>
<thead>
<tr>
<th>版本号</th>
<th>代号</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>4.10（初始发布版本）</td>
<td>Warty Warthog</td>
<td>2004-10-20</td>
</tr>
<tr>
<td>16.04 LTS</td>
<td>Xenial Xerus</td>
<td>2016-04-21</td>
</tr>
<tr>
<td>18.04 LTS</td>
<td>Bionic Beaver</td>
<td>2018-04-26</td>
</tr>
<tr>
<td>20.04 LTS</td>
<td>Focal Fossa</td>
<td>2020-04-23</td>
</tr>
<tr>
<td>22.04</td>
<td>Jammy Jellyfish</td>
<td>2022-04-22</td>
</tr>
</tbody></table>
<h3 id="软件源结构"><a href="#软件源结构" class="headerlink" title="软件源结构"></a>软件源结构</h3><blockquote>
<p>Ubuntu的软件软分为两部分官方源和ppa，ppa其实是一个网站，即－launchpad.net。Launchpad 是 Ubuntu 母公司 Canonical 有限公司所架设的网站，是一个提供维护、支援或联络 Ubuntu 开发者的平台。由于不是所有的软件都能进入 Ubuntu 的官方的软件库，launchpad.net 提供了 PPA，允许开发者建立自己的软件仓库，自由的上传软件。供用户安装和查看更新。</p>
</blockquote>
<p>整个软件源结构可以分解为四个部分:</p>
<p>第一部分 第二部分 第三部分 第四部分<br>软件包格式 软件包服务器地址 发行版版本代号 软件包的分类目录<br>deb/deb-src <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a>  xenial/xenial-updates/xenial-security/xenial-backports/proposed main、restricted、universe、multiverse<br>第一部分的deb是deb软件包，deb-src则是源代码包</p>
<p>第三部分严格来说不算是发行版版本代号，它应该是Ubuntu系统发布之后，在此基础上进行的安全性更新的分类。</p>
<p>第四部分是按照软件包的自由度来分类的：</p>
<p>main：即“基本”组件，其中只包含符合Ubuntu的协议要求并由Ubuntu团队维护支持的软件。</p>
<p>restricted：即“受限”组件，其中包含了非常重要的，但并不具有合适的自由协议的软件，如显卡驱动，同样有 Ubuntu团队维护支持。</p>
<p>universe：即“社区维护”组件，其中包含的软件种类繁多，它们可能采用受限于协议，可能不是，但都不为Ubuntu 团队维护。</p>
<p>multiverse：即“非自由”组件，其中包括了不符合自由软体要求而且不被Ubuntu团队支援的软件，通常为商业公司编写的软件。</p>
<p>下面我们来看一下Ubuntu软件源镜像站的目录结构（以阿里云镜像站为例）：</p>
<p><a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> ，在浏览器地址栏中输入此地址便进入了Ubuntu软件源镜像站，如下图所示：</p>
<p>重点看两个文件夹dists和pool</p>
<p>dists目录包含的全是Ubuntu发行版目录及其附加仓库目录（如：xenial、xenial-update、xenial-security、xenial-backports就是Ubuntu xenial发行版目录及其附加仓库目录）。</p>
<p>pool/:</p>
<p>所有 Ubuntu 发布版及已发布版的软件包的物理地址。按照源码包名称分类存放。pool目录下按属性再分类（main、restricted、 universe和multiverse），分类下面再按源码包名称的首字母归档。这些目录包含的文件有：运行于各种系统架构的二进制软件包，生成这些二进制软件包的源码包。  </p>
<p>我们知道Ubuntu还有其他的附加仓库，Ubuntu附加仓库的命名格式是“版本代号-限定词”，限定词是这update、security、proposed、backports四个词中的一个，比方说版本代号xenial和限定词update组合就是xenial-update附加仓库，xenial和security组合就是xenial-security附加仓库，以此类推可以自行写出Ubuntu所有的附加仓库的目录名称</p>
<p>在sources.list文件里只有一条包含发行版仓库xenial的软件源还不够，我们还要写出包含其他4个附加仓库的软件源，只要把已经写好的软件源中的xenial依次替换成xenial-update、xenial-security、xenial-proposed、xenial-backports即可，下面是完整的包含所有附加仓库的软件源：</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-update main universe restricted multiverse</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-security main universe restricted multiverse</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-proposed main universe restricted multiverse</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial-backports main universe restricted multiverse</p>
<p>将这四条软件源再一并写入sources.list，再加上</p>
<p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/ubuntu/">http://mirrors.aliyun.com/ubuntu/</a> xenial main universe restricted multiverse</p>
<p>总共五条</p>
<p>另外为了防止运营商劫持大家可以使用https，但是要求镜像站支持https，一般现在大型镜像站都是支持https的，比如清华镜像站，阿里镜像站，163等等</p>
<h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>版本 开发代号 中译 发布日期 支持结束时间  内核版本<br>桌面版 服务器版<br>4.10 Warty Warthog 多疣的 疣猪 2004-10-20 2006-04-30 2.6.8<br>5.04 Hoary Hedgehog 白发的 刺猬 2005-04-08 2006-10-31 2.6.10<br>5.10 Breezy Badger 活泼的 獾 2005-10-13 2007-04-13 2.6.12<br>6.06 LTS Dapper Drake 整洁的公 鸭 2006-06-01 2009-07-14 2011-06-01 2.6.15<br>6.10 Edgy Eft 尖利的小 蜥蜴 2006-10-26 2008-04-25 2.6.17<br>7.04 Feisty Fawn 烦躁不安的 鹿 2007-04-19 2008-10-19 2.6.20<br>7.10 Gutsy Gibbon 胆大的 长臂猿 2007-10-18 2009-04-18 2.6.22<br>8.04 LTS Hardy Heron 坚强的 鹭 2008-04-24 2011-05-12 2013-05-09 2.6.24<br>8.10 Intrepid Ibex 无畏的 羱羊 2008-10-30 2010-04-30 2.6.27<br>9.04 Jaunty Jackalope 活泼的 鹿角兔 2009-04-23 2010-10-23 2.6.28<br>9.10 Karmic Koala 幸运的 树袋熊 2009-10-29 2011-04-30 2.6.31<br>10.04 LTS Lucid Lynx 清醒的 山猫 2010-04-29 2013-05-09 2015-04-30 2.6.32<br>10.10 Maverick Meerkat 标新立异的 狐獴 2010-10-10 2012-04-10 2.6.35<br>11.04 Natty Narwhal 敏捷的 独角鲸 2011-04-28 2012-10-28 2.6.38<br>11.10 Oneiric Ocelot 有梦的 虎猫 2011-10-13 2013-05-09 3.0<br>12.04 LTS Precise Pangolin 精准的 穿山甲 2012-04-26 [39] 2017-04-28 [40] 3.2 [41]<br>12.10 Quantal Quetzal 量子的 格查尔鸟 2012-10-18 2014-05-16 [42] 3.5 [43]<br>13.04 Raring Ringtail 铆足了劲的 环尾猫熊 2013-04-25 2014-01-27 [44] 3.8 [45]<br>13.10 Saucy Salamander 活泼的 蝾螈 2013-10-17 [46] 2014-07-17 [47] 3.11<br>14.04 LTS Trusty Tahr 可靠的 塔尔羊 2014-04-17 [48] 2019-04 3.13<br>14.10 Utopic Unicorn 乌托邦的 独角兽 2014-10-23 [49] 2015-07-23 [50] 3.16 [51]<br>15.04 Vivid Vervet 活泼的 长尾黑颚猴 2015-04-23 [52] 2016-02-04 [53] 3.19 [54]<br>15.10 Wily Werewolf 老谋深算的 狼人 2015-10-22 [55] 2016-07-28 [56] 4.2 [57]<br>16.04 LTS Xenial Xerus 好客的 非洲地松鼠 2016-04-21 [58] 2021-04 4.4 [59]<br>16.10 Yakkety Yak 喋喋不休的 牦牛 2016-10-13 [60] 2017-07-20 4.8<br>17.04 Zesty Zapus 热情的 美洲林跳鼠 2017-04-13 [61] 2018-01-13 4.10 [62]<br>17.10 Artful Aardvark 巧妙的 土豚 2017-10-19 [63] 2018-07-19 4.13 [64]<br>18.04 LTS Bionic Beaver [65] [66] 仿生的 海狸 2018-04-26 [67] 2028-04 [68] 4.15<br>18.10 Cosmic Cuttlefish 宇宙的 墨鱼 2018-10-18 [69] 2019-07 4.18 [70]</p>
<p>19.04 Disco Dingo 迪斯可的 澳洲野犬 2019-04-18 [71] 2020-01 TBA</p>
<h2 id="ROS安装"><a href="#ROS安装" class="headerlink" title="ROS安装"></a>ROS安装</h2><ol>
<li><p><img src="https://img-blog.csdnimg.cn/20191118143433409.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNDUwODEx,size_16,color_FFFFFF,t_70" alt="img"></p>
</li>
<li><p>设置软件源</p>
</li>
</ol>
<p><code>sudo sh -c &#39;. /etc/lsb-release &amp;&amp; echo &quot;deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&#39;</code></p>
<ol start="3">
<li><p>设置密钥</p>
<p><code>sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654</code></p>
</li>
<li><p>安装</p>
<blockquote>
<p>sudo apt-get update<br>sudo apt-get install ros-melodic-desktop-full<br>sudo apt-get install ros-melodic-rqt*</p>
</blockquote>
</li>
<li><p>初始化rosdep</p>
<blockquote>
<p>sudo apt-get install python-rosdep</p>
<p>sudo rosdep init<br>rosdep update</p>
</blockquote>
</li>
<li><p>配置环境变量</p>
<blockquote>
<p>source /opt/ros/melodic/setup.bash</p>
<p>#ifconfig查看你的电脑ip地址<br>export ROS_HOSTNAME=localhost<br>export ROS_MASTER_URI=<a target="_blank" rel="noopener" href="http://${ros_hostname}:11311/">http://${ROS_HOSTNAME}:11311</a></p>
</blockquote>
</li>
</ol>
<h2 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h2><blockquote>
<p>export http_proxy=”http://<user>:<password>@<proxy_server>:<port>“<br>export https_proxy=”http://<user>:<password>@<proxy_server>:<port>“<br>export http_proxy=”socks5://127.0.0.1:1080”<br>export https_proxy=”socks5://127.0.0.1:1080”<br>export ftp_proxy=&lt;http://<user>:<password>@<proxy_server>:<port>&gt;</p>
</blockquote>
<h2 id="更改文件夹下所有文件的权限"><a href="#更改文件夹下所有文件的权限" class="headerlink" title="更改文件夹下所有文件的权限"></a>更改文件夹下所有文件的权限</h2><blockquote>
<p>sudo chmod -R 777 filename</p>
</blockquote>
<h2 id="git常用操作"><a href="#git常用操作" class="headerlink" title="git常用操作"></a>git常用操作</h2><blockquote>
<p>$ git config –global user.name “username”</p>
<p>$ git config –global user.email “email”</p>
<p>用vscode多方便<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>
</blockquote>
<h2 id="中文输入法"><a href="#中文输入法" class="headerlink" title="中文输入法"></a>中文输入法</h2><p>ubuntu 在最新的版本中已经可以不用用户自己单独去下载中文输入法使用了，本次使用为 ubuntu18.04LTS版本(登陆是界面选择的是ubuntu on wayland)，设置方式非常简单</p>
<p>1、打开设置，不知道的请点击右上角的工具栏即可看到。</p>
<p>2、找到设置中语言项，点击语言安装管理，安装中文语言后选择输入方式。</p>
<p>点击关闭，然后添加输入语言，在其中找到中文拼音添加即可</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yedongsheng8238045/article/details/107185130/">https://blog.csdn.net/yedongsheng8238045/article/details/107185130/</a></p>
<h2 id="eigen库路径问题"><a href="#eigen库路径问题" class="headerlink" title="eigen库路径问题"></a>eigen库路径问题</h2><p>大多数的程序包含的都是 &lt;Eigen/Dense&gt; 头文件, 如果想这样包含的话需要将 eigen 下的 Eigen 文件提升一级目录, 即将 Eigen 从 /usr/include/eigen3 放到 /usr/include/ 下, 如下命令:</p>
<p>sudo cp -r  /usr/include/eigen3/Eigen /usr/include/</p>
<h2 id="eigen-vector3d"><a href="#eigen-vector3d" class="headerlink" title="eigen:vector3d"></a>eigen:vector3d</h2><p>Eigen::Vector3d默认定义为一个列向量</p>
<p>Eigen::Vector3d T(2, 1, 6)<br>std::cout &lt;&lt; “T = \n” &lt;&lt; T &lt;&lt; std::endl;<br>std::cout &lt;&lt; “T.transpose() = \n” &lt;&lt; T.transpose() &lt;&lt; std::endl;<br>1<br>2<br>3<br>输出结果为：</p>
<p>T =<br>2<br>1<br>6<br>T.transpose() =<br>2  1  6</p>
<h2 id="eigen-matrix"><a href="#eigen-matrix" class="headerlink" title="eigen::matrix"></a>eigen::matrix</h2><p>直接输出</p>
<h2 id="man-zh-cn"><a href="#man-zh-cn" class="headerlink" title="man zh_cn"></a>man zh_cn</h2><p>1.安装中文man手册<br>sudo apt-get install manpages-zh<br>2.查看中文man手册安装路径<br>dpkg -L manpages-zh | less</p>
<p><img src="https://gitee.com/Pleasecallmeboss/tuchuang/raw/master/Note/man%E4%BD%8D%E7%BD%AE.png"></p>
<p>可见中文man手册是安装在路径/usr/share/man/zh_CN/下</p>
<p>3.给中文man设置一个命令<br>为了和系统原来的man区分开，用alias给中文man的命令设置一个别名</p>
<p>alias cman=’man -M /usr/share/man/zh_CN’<br>为永久生效，可把上面的命令写进启动文件中<br>如：修改 ~/.bashrc ，添加上面的命令<br>我修改的是 /etc/bash.bashrc<br>=======</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>9fe0423c3a24031c913d166b3ac7ff3ebdfc73d8<br>3d419ebd75fa478d0e144fedfe1049e3bc140131</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h2 id="网卡驱动安装"><a href="#网卡驱动安装" class="headerlink" title="网卡驱动安装"></a>网卡驱动安装</h2><p><a target="_blank" rel="noopener" href="https://www.lxlinux.net/install-network-card-driver-on-linux.html">https://www.lxlinux.net/install-network-card-driver-on-linux.html</a></p>
<h2 id="设置sudo免密"><a href="#设置sudo免密" class="headerlink" title="设置sudo免密"></a>设置sudo免密</h2><p>运行sudo visudo在打开的页面将</p>
<pre><code class="text">%sudo ALL=(ALL:ALL) ALL
</code></pre>
<p>改为</p>
<pre><code class="text">%sudo  ALL=(ALL:ALL) NOPASSWD:ALL 
</code></pre>
<h2 id="返回上一次的目录"><a href="#返回上一次的目录" class="headerlink" title="返回上一次的目录"></a>返回上一次的目录</h2><p>cd -</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/blog/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">咦蜘蛛</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/blog/archives">
          <span class="site-state-item-count">25</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/blog/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/blog/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">咦蜘蛛</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/blog/lib/anime.min.js"></script>
  <script src="/blog/lib/velocity/velocity.min.js"></script>
  <script src="/blog/lib/velocity/velocity.ui.min.js"></script>

<script src="/blog/js/utils.js"></script>

<script src="/blog/js/motion.js"></script>


<script src="/blog/js/schemes/muse.js"></script>


<script src="/blog/js/next-boot.js"></script>




  















  

  

</body>
</html>
